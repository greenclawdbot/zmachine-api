import * as readline from "readline-sync";
import chalk from "chalk";
import { ScreenBase, Color, TextStyle, BufferMode, } from "../Screen.js";
export default class StdioScreen extends ScreenBase {
    constructor(log) {
        super(log, "StdioScreen");
        this.textStyle = TextStyle.Roman;
        this.outputWindowId = 0;
        this.bufferMode = BufferMode.Buffered;
        this.colors = {
            0: {
                foreground: Color.Default,
                background: Color.Default,
            },
        };
    }
    getCapabilities() {
        return {
            hasColors: true,
            hasBold: true,
            hasItalic: false,
            hasReverseVideo: true,
            hasFixedPitch: false,
            hasSplitWindow: false,
            hasDisplayStatusBar: false,
            hasPictures: false,
            hasSound: false,
            hasTimedKeyboardInput: false,
        };
    }
    getInputFromUser(game, input_state) {
        const input = readline.question("");
        game.continueAfterUserInput(input_state, input);
    }
    getKeyFromUser(game, input_state) {
        const input = readline.keyIn("", { hideEchoBack: true });
        game.continueAfterUserInput(input_state, input);
    }
    applyStyles(str) {
        if (this.textStyle & TextStyle.ReverseVideo) {
            str = chalk.inverse(str);
        }
        if (this.textStyle & TextStyle.Bold) {
            str = chalk.bold(str);
        }
        if (this.textStyle & TextStyle.Italic) {
            str = chalk.italic(str);
        }
        return str;
    }
    applyColors(str) {
        const chalkedString = (str, color, bg) => {
            switch (color) {
                case Color.Black:
                    return bg ? chalk.bgBlack(str) : chalk.black(str);
                case Color.Red:
                    return bg ? chalk.bgRed(str) : chalk.red(str);
                case Color.Green:
                    return bg ? chalk.bgGreen(str) : chalk.green(str);
                case Color.Yellow:
                    return bg ? chalk.bgYellow(str) : chalk.yellow(str); // bgOrNot("Yellow", bg);
                case Color.Blue:
                    return bg ? chalk.bgBlue(str) : chalk.blue(str);
                case Color.Magenta:
                    return bg ? chalk.bgMagenta(str) : chalk.magenta(str);
                case Color.Cyan:
                    return bg ? chalk.bgCyan(str) : chalk.cyan(str);
                case Color.White:
                    return bg ? chalk.bgWhite(str) : chalk.white(str);
                case Color.Gray:
                    // because why be consistent?  ugh, chalk.
                    return bg ? chalk.bgBlackBright(str) : chalk.gray(str);
                default:
                    throw new Error("unrecognized color");
            }
        };
        if (this.colors[this.outputWindowId].background !== Color.Default) {
            str = chalkedString(str, this.colors[this.outputWindowId].background, true);
        }
        if (this.colors[this.outputWindowId].foreground !== Color.Default) {
            str = chalkedString(str, this.colors[this.outputWindowId].foreground, false);
        }
        return str;
    }
    print(game, str) {
        if (this.outputWindowId !== 0) {
            return;
        }
        str = this.applyStyles(str);
        str = this.applyColors(str);
        process.stdout.write(str);
    }
    setOutputWindow(game, windowId) {
        this.outputWindowId = windowId;
    }
    getOutputWindow(_game) {
        return this.outputWindowId;
    }
    setBufferMode(game, mode) {
        this.bufferMode = mode;
    }
    setTextStyle(game, style) {
        this.textStyle = style;
    }
    setTextColors(game, windowId, foreground, background) {
        const newColors = { foreground, background };
        if (newColors.foreground === Color.Current) {
            newColors.foreground = this.colors[windowId].foreground;
        }
        if (newColors.background === Color.Current) {
            newColors.background = this.colors[windowId].background;
        }
        this.colors[windowId] = newColors;
    }
    getSize() {
        return { cols: 80, rows: 255 /* 255 == infinite height */ };
    }
}
//# sourceMappingURL=stdio-screen.js.map