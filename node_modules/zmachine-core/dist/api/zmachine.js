import CPU from '../engine/cpu';
import Game from '../resources/game';
import GameState from '../state/game';
import ScreenState from '../state/screen';
import ScreenResource from '../resources/screen';
import Input from '../resources/input';
export default class ZMachine {
    // With the exception of keyPress, the methods of this class
    // should be called once before calling loadStory to start the game
    // Optional methods are be marked optional
    // When the screen has changed, the Z-Machine will call the screenSetter with the updated screen
    static attachScreenSetter(setter) {
        ScreenState.attachSetter(setter);
    }
    // The status setter lets the Z-Machine tell the app its status
    // START, LOADING, RUNNING, QUIT, or ERROR
    static attachStatusSetter(setter) {
        GameState.attachStatusSetter(setter);
    }
    // Start the game by calling loadStory with the array of bytes from the story file
    static loadStory(file) {
        try {
            GameState.setStatus({
                type: 'LOADING',
            });
            Game.loadStory(file);
            CPU.run();
            GameState.setStatus({
                type: 'RUNNING',
            });
        }
        catch (error) {
            const message = `${(error && error.message) || 'An unexpected error occurred'}`;
            GameState.setStatus({
                type: 'ERROR',
                message,
            });
        }
    }
    // When the game is running keypresses should be forwarded to the Z-Machine
    // by calling keyPress
    static keyPress(key) {
        if (!Input.keyPress(key)) {
            // eslint-disable-next-line no-console
            console.log(`Unexpected keypress ${key}`);
        }
    }
    // Optionally set the size in pixels of the app
    // Defaults to a 80x24 screen with a line height of 16 and monospace character width of 8
    static setAppSize(width, height) {
        return ScreenResource.setAppSize(width, height);
    }
    // An Optional DataSaver should asyncronously store bytes in a durable way
    // Used for saving games and writing auxiliary files
    // It should throw Errors on failure
    // By default it always reports failures to the game
    static attachDataSaver(saver) {
        GameState.attachSaver(saver);
    }
    // An Optional DataLoader should asyncronously retrieve bytes from durable storage
    // Used for restoring games and reading auxiliary files
    // It should throw Errors on failure
    // By default it always reports failures to the game
    static attachDataLoader(loader) {
        GameState.attachLoader(loader);
    }
    // An optional NoiseMaker should expect calls with noise types 'BEEP' and 'BOOP'
    // By default noises are logged to the console
    static attachNoiseMaker(noiseMaker) {
        GameState.attachNoiseMaker(noiseMaker);
    }
    // An optional TranscriptWriter should expect calls with lines of text
    // By default the transcript is logged to the console
    static attachTranscriptWriter(transcriptWriter) {
        GameState.attachTranscriptWriter(transcriptWriter);
    }
    // An optional CommandRecorder should expect calls with command strings
    // by default recorded commands are queued in memory
    static attachCommandRecorder(commandRecorder) {
        GameState.attachCommandRecorder(commandRecorder);
    }
    // An optional CommandReplayer should return command strings
    // by default commands are pulled from a queue in memory
    static attachCommandReplayer(commandReplayer) {
        GameState.attachCommandReplayer(commandReplayer);
    }
}
