/* eslint-disable no-await-in-loop */
// this worker evaluates the instruction at the Program counter and executes it repeatedly
import PC from '../state/pc';
import GameState from '../state/game';
import Header from '../resources/header';
import Routine from '../resources/routine';
import Variable from '../resources/variable';
import OPS from '../ops/dispatch';
import { LARGE_ARG, SMALL_ARG, VARIABLE_ARG, OMITTED_ARG, ARGS_0_RETURN, ARGS_0_VOID, ARGS_1_RETURN, ARGS_1_VOID, ARGS_2_RETURN, ARGS_2_VOID, ARGS_4_RETURN, ARGS_4_VOID, ARGS_8_RETURN, ARGS_8_VOID, EXTENDED_OPCODE, QUIT, } from '../ops/types';
const QUIT_DELAY_MILLISECONDS = 10000;
function read4ArgTypes() {
    const types = PC.readCrumbs();
    let omission = false;
    for (let i = 0; i < 4; i += 1) {
        if (types[i] === OMITTED_ARG) {
            omission = true;
        }
        else if (omission) {
            throw new Error('Argument present after ommission');
        }
    }
    return types;
}
function read8ArgTypes() {
    const t1 = PC.readCrumbs();
    const t2 = PC.readCrumbs();
    const types = [
        t1[0], t1[1], t1[2], t1[3], t2[0], t2[1], t2[2], t2[3],
    ];
    let omission = false;
    for (let i = 0; i < 8; i += 1) {
        if (types[i] === OMITTED_ARG) {
            omission = true;
        }
        else if (omission) {
            throw new Error('Argument present after ommission');
        }
    }
    return types;
}
function readArg(type) {
    if (type === LARGE_ARG) {
        return PC.readWord();
    }
    if (type === SMALL_ARG) {
        return PC.readByte();
    }
    if (type === VARIABLE_ARG) {
        const varnum = PC.readByte();
        return Variable.readVar(varnum);
    }
    if (type === OMITTED_ARG) {
        return null;
    }
    throw new Error(`Unexpected ArgType ${type} in readArg`);
}
class CPU {
    constructor() {
        this.running = false;
        this.debug = false;
    }
    logOp(options) {
        if (this.debug) {
            let s = '';
            if (options) {
                if (options.cycles) {
                    s += ` ${options.cycles}`;
                }
                if (options.pc) {
                    s += ` ${options.pc}:`;
                }
                if (options.opcode) {
                    s += ` ${options.opcode}`;
                }
                if (options.name) {
                    s += ` ${options.name}`;
                }
                if (options.args) {
                    s += `(${options.args.map((x) => `${x}`).join(',')})`;
                }
            }
            // eslint-disable-next-line no-console
            console.log(s);
        }
    }
    async run() {
        let cycles = 0;
        try {
            if (this.running) {
                GameState.setStatus({
                    type: 'ERROR',
                    message: 'CPU.run was called twice',
                });
                return;
            }
            this.running = true;
            const version = Header.version();
            for (;;) {
                // read instruction at PC
                const pc = PC.getPC();
                let opcode = PC.readByte();
                if (opcode === EXTENDED_OPCODE) {
                    opcode = PC.readByte() + 256;
                }
                const OP = OPS[opcode];
                if (!OP) {
                    throw new Error(`${cycles}: Undefined Op Code ${opcode}`);
                }
                if (OP.version > version) {
                    throw new Error(`${cycles}: Op Code ${opcode} illegal in version ${version}`);
                }
                const { name } = OP;
                let result = null;
                if (OP.kind === ARGS_0_RETURN || OP.kind === ARGS_0_VOID) {
                    this.logOp({
                        cycles, pc, opcode, name,
                    });
                    if (OP.kind === ARGS_0_RETURN) {
                        result = await OP.method();
                    }
                    else {
                        await OP.method();
                    }
                }
                else if (OP.kind === ARGS_1_RETURN || OP.kind === ARGS_1_VOID) {
                    const args1 = readArg(OP.types[0]);
                    this.logOp({
                        cycles, pc, opcode, name, args: [args1],
                    });
                    if (OP.kind === ARGS_1_RETURN) {
                        result = await OP.method(args1);
                    }
                    else {
                        await OP.method(args1);
                    }
                }
                else if (OP.kind === ARGS_2_RETURN || OP.kind === ARGS_2_VOID) {
                    const args1 = readArg(OP.types[0]);
                    const args2 = readArg(OP.types[1]);
                    this.logOp({
                        cycles, pc, opcode, name, args: [args1, args2],
                    });
                    if (OP.kind === ARGS_2_RETURN) {
                        result = await OP.method(args1, args2, null, null);
                    }
                    else {
                        await OP.method(args1, args2, null, null);
                    }
                }
                else if (OP.kind === ARGS_4_RETURN || OP.kind === ARGS_4_VOID) {
                    const types = read4ArgTypes();
                    const args1 = readArg(types[0]);
                    const args2 = readArg(types[1]);
                    const args3 = readArg(types[2]);
                    const args4 = readArg(types[3]);
                    this.logOp({
                        cycles, pc, opcode, name, args: [args1, args2, args3, args4],
                    });
                    if (OP.kind === ARGS_4_RETURN) {
                        result = await OP.method(args1, args2, args3, args4);
                    }
                    else {
                        await OP.method(args1, args2, args3, args4);
                    }
                }
                else if (OP.kind === ARGS_8_RETURN || OP.kind === ARGS_8_VOID) {
                    const types = read8ArgTypes();
                    const args1 = readArg(types[0]);
                    const args2 = readArg(types[1]);
                    const args3 = readArg(types[2]);
                    const args4 = readArg(types[3]);
                    const args5 = readArg(types[4]);
                    const args6 = readArg(types[5]);
                    const args7 = readArg(types[6]);
                    const args8 = readArg(types[7]);
                    this.logOp({
                        cycles,
                        pc,
                        opcode,
                        name,
                        args: [args1, args2, args3, args4, args5, args6, args7, args8],
                    });
                    if (OP.kind === ARGS_8_RETURN) {
                        result = await OP.method(args1, args2, args3, args4, args5, args6, args7, args8);
                    }
                    else {
                        await OP.method(args1, args2, args3, args4, args5, args6, args7, args8);
                    }
                }
                else {
                    throw new Error(`Unexpected OP.kind ${OP}`);
                }
                if (OP.store) {
                    if (result === null) {
                        throw new Error(`${cycles}: Op Code ${opcode} stores without return`);
                    }
                    Routine.store(result);
                }
                if (OP.branch) {
                    if (result === null) {
                        throw new Error(`${cycles}: Op Code ${opcode} branches without return`);
                    }
                    await Routine.branch(result);
                }
                cycles += 1;
            }
        }
        catch (error) {
            this.running = false;
            if (error && error.message === QUIT) {
                setTimeout(() => GameState.setStatus({
                    type: 'QUIT',
                }), QUIT_DELAY_MILLISECONDS);
            }
            else {
                // eslint-disable-next-line no-console
                console.log('Game ending due to error');
                // eslint-disable-next-line no-console
                console.log(error);
                const message = `${(error && error.message) || 'An unexpected error occurred'}`;
                GameState.setStatus({
                    type: 'ERROR',
                    message,
                });
            }
        }
    }
}
const instance = new CPU();
export default instance;
