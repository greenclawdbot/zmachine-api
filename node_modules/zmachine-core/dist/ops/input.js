// OP codes which deal with reading input are defined here
import Dictionary from '../resources/dictionary';
import Header from '../resources/header';
import Input from '../resources/input';
import InputState from '../state/input';
import Status from '../resources/status';
import { isBadArg, throwBadArg } from './types';
/* eslint-disable @typescript-eslint/camelcase */
export default class InputOps {
    static async read(text, parse, time, routine) {
        const version = Header.version();
        if (isBadArg(text)) {
            throwBadArg();
        }
        if (version <= 3) {
            Status.showStatus();
        }
        if (version < 5 && (parse === null || parse === 0)) {
            throw new Error(`missing parse table ${parse}`);
        }
        const parseAddr = parse || 0;
        if (version >= 4 && time !== null && time > 0 && routine !== null) {
            await Input.timedRead(text, parseAddr, time, routine);
        }
        else {
            await Input.untimedRead(text, parseAddr);
        }
    }
    static async read_char(one, time, routine) {
        if (one === 1 && time !== null && time > 0 && routine !== null) {
            await Input.timedReadChar(time, routine);
        }
        else {
            await Input.untimedReadChar();
        }
    }
    static input_stream(number) {
        if (isBadArg(number)) {
            throwBadArg();
        }
        if (number !== 0 && number !== 1) {
            throw new Error(`Unexpected number ${number}`);
        }
        InputState.setActiveStream(number);
    }
    static tokenise(text, parse, dictionary, flag) {
        if (isBadArg(text) || isBadArg(parse)) {
            throwBadArg();
        }
        let skipUnknown = false;
        if (flag) {
            skipUnknown = true;
        }
        Dictionary.tokenise(text, parse, dictionary, skipUnknown);
    }
    static encode_text(zsciiText, length, from, codedText) {
        if (isBadArg(zsciiText) || isBadArg(length) || isBadArg(from) || isBadArg(codedText)) {
            throwBadArg();
        }
        Dictionary.encodeText(zsciiText, length, from, codedText);
    }
}
