// OP codes which deal with math are defined here
import Random from '../state/random';
import { BIT_15, BIT_16, WORD_MASK, BITS, } from '../utils/constants';
import { isBadArg, throwBadArg } from './types';
/* eslint-disable @typescript-eslint/camelcase */
export default class MathOps {
    static add(a, b) {
        if (isBadArg(a) || isBadArg(b)) {
            throwBadArg();
        }
        const total = a + b;
        if (total >= BIT_16) {
            return total - BIT_16;
        }
        return total;
    }
    static and(a, b) {
        if (isBadArg(a) || isBadArg(b)) {
            throwBadArg();
        }
        // eslint-disable-next-line no-bitwise
        return a & b;
    }
    static art_shift(number, places) {
        if (isBadArg(number) || isBadArg(places)) {
            throwBadArg();
        }
        let signedPlaces = places;
        if (signedPlaces >= BIT_15) {
            signedPlaces -= BIT_16;
        }
        let signedNumber = number;
        if (signedNumber >= BIT_15) {
            signedNumber -= BIT_16;
        }
        if (signedPlaces > 15) {
            return 0;
        }
        if (signedPlaces < -15) {
            if (signedNumber >= 0) {
                return 0;
            }
            return BIT_16 - 1;
        }
        let result;
        if (signedPlaces < 0) {
            const twoToTheN = BITS[-signedPlaces];
            if (signedNumber >= 0) {
                result = (signedNumber - (signedNumber % twoToTheN)) / twoToTheN;
            }
            else {
                // strange rounding away from zero
                const value = -signedNumber + twoToTheN - 1;
                result = -((value - (value % twoToTheN)) / twoToTheN);
            }
        }
        else {
            result = (signedNumber * BITS[signedPlaces]) % BIT_16;
        }
        if (result < 0) {
            result += BIT_16;
        }
        return result;
    }
    static div(a, b) {
        if (isBadArg(a) || isBadArg(b)) {
            throwBadArg();
        }
        if (b === 0) {
            throw new Error('division by zero');
        }
        let signedA = a;
        if (signedA >= BIT_15) {
            signedA -= BIT_16;
        }
        let signedB = b;
        if (signedB >= BIT_15) {
            signedB -= BIT_16;
        }
        let result = signedA / signedB;
        if (result >= 0) {
            result = Math.floor(result);
        }
        else {
            result = Math.ceil(result);
        }
        if (result < 0) {
            result += BIT_16;
        }
        return result;
    }
    static je(a, b, c, d) {
        if (isBadArg(a)) {
            throwBadArg();
        }
        if (a === b) {
            return 1;
        }
        if (a === c) {
            return 1;
        }
        if (a === d) {
            return 1;
        }
        return 0;
    }
    static jg(a, b) {
        if (isBadArg(a) || isBadArg(b)) {
            throwBadArg();
        }
        let signedA = a;
        if (signedA >= BIT_15) {
            signedA -= BIT_16;
        }
        let signedB = b;
        if (signedB >= BIT_15) {
            signedB -= BIT_16;
        }
        if (signedA > signedB) {
            return 1;
        }
        return 0;
    }
    static jl(a, b) {
        if (isBadArg(a) || isBadArg(b)) {
            throwBadArg();
        }
        let signedA = a;
        if (signedA >= BIT_15) {
            signedA -= BIT_16;
        }
        let signedB = b;
        if (signedB >= BIT_15) {
            signedB -= BIT_16;
        }
        if (signedA < signedB) {
            return 1;
        }
        return 0;
    }
    static jz(a) {
        if (isBadArg(a)) {
            throwBadArg();
        }
        if (a === 0) {
            return 1;
        }
        return 0;
    }
    static log_shift(number, places) {
        if (isBadArg(number) || isBadArg(places)) {
            throwBadArg();
        }
        let signedPlaces = places;
        if (signedPlaces >= BIT_15) {
            signedPlaces -= BIT_16;
        }
        if (signedPlaces > 15 || signedPlaces < -15) {
            return 0;
        }
        if (signedPlaces < 0) {
            const twoToTheN = BITS[-signedPlaces];
            return (number - (number % twoToTheN)) / twoToTheN;
        }
        return (number * BITS[signedPlaces]) % BIT_16;
    }
    static not(a) {
        if (isBadArg(a)) {
            throwBadArg();
        }
        // eslint-disable-next-line no-bitwise
        return WORD_MASK & (~a);
    }
    static mod(a, b) {
        if (isBadArg(a) || isBadArg(b)) {
            throwBadArg();
        }
        if (b === 0) {
            throw new Error('division by zero');
        }
        let signedA = a;
        if (signedA >= BIT_15) {
            signedA -= BIT_16;
        }
        let signedB = b;
        if (signedB >= BIT_15) {
            signedB -= BIT_16;
        }
        let divResult = signedA / signedB;
        if (divResult >= 0) {
            divResult = Math.floor(divResult);
        }
        else {
            divResult = Math.ceil(divResult);
        }
        let modResult = signedA - (divResult * signedB);
        if (modResult < 0) {
            modResult += BIT_16;
        }
        return modResult;
    }
    static mul(a, b) {
        if (isBadArg(a) || isBadArg(b)) {
            throwBadArg();
        }
        return (a * b) % BIT_16;
    }
    static or(a, b) {
        if (isBadArg(a) || isBadArg(b)) {
            throwBadArg();
        }
        // eslint-disable-next-line no-bitwise
        return a | b;
    }
    static sub(a, b) {
        if (isBadArg(a) || isBadArg(b)) {
            throwBadArg();
        }
        const total = a - b;
        if (total < 0) {
            return total + BIT_16;
        }
        return total;
    }
    static random(range) {
        if (isBadArg(range)) {
            throwBadArg();
        }
        let signedRange = range;
        if (signedRange >= BIT_15) {
            signedRange -= BIT_16;
        }
        if (signedRange > 0) {
            return Random.random(signedRange);
        }
        Random.seed(-signedRange);
        return 0;
    }
    static test(bitmap, flags) {
        if (isBadArg(bitmap) || isBadArg(flags)) {
            throwBadArg();
        }
        // eslint-disable-next-line no-bitwise
        if ((bitmap & flags) === flags) {
            return 1;
        }
        return 0;
    }
}
