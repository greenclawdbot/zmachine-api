// OP codes which deal with memory access are defined here
import Memory from '../state/memory';
import { isBadArg, throwBadArg } from './types';
import { BIT_7, BIT_15, BIT_16 } from '../utils/constants';
/* eslint-disable @typescript-eslint/camelcase */
export default class MemoryOps {
    static copy_table(first, second, size) {
        if (isBadArg(first) || isBadArg(second) || isBadArg(size)) {
            throwBadArg();
        }
        if (second === 0) {
            // zero the first table
            for (let i = 0; i < size; i += 1) {
                Memory.setByte(first + i, 0);
            }
            return;
        }
        let forward = second < first;
        let bytes = size;
        if (bytes >= BIT_15) {
            bytes = BIT_16 - bytes;
            forward = true;
        }
        if (forward) {
            for (let i = 0; i < bytes; i += 1) {
                Memory.setByte(second + i, Memory.getByte(first + i));
            }
        }
        else {
            for (let i = bytes - 1; i >= 0; i -= 1) {
                Memory.setByte(second + i, Memory.getByte(first + i));
            }
        }
    }
    static loadb(array, byteIndex) {
        if (isBadArg(array) || isBadArg(byteIndex)) {
            throwBadArg();
        }
        let signedIndex = byteIndex;
        if (signedIndex >= BIT_15) {
            signedIndex -= BIT_16;
        }
        return Memory.getByte(array + signedIndex);
    }
    static loadw(array, wordIndex) {
        if (isBadArg(array) || isBadArg(wordIndex)) {
            throwBadArg();
        }
        let signedIndex = wordIndex;
        if (signedIndex >= BIT_15) {
            signedIndex -= BIT_16;
        }
        return Memory.getWord(array + (2 * signedIndex));
    }
    static scan_table(x, table, len, form) {
        if (isBadArg(x) || isBadArg(table) || isBadArg(len)) {
            throwBadArg();
        }
        let fieldSize = 2;
        let words = true;
        if (form !== null) {
            // eslint-disable-next-line no-bitwise
            if ((form & BIT_7) === 0) {
                words = false;
            }
            fieldSize = form % BIT_7;
        }
        for (let i = 0; i < len; i += 1) {
            let value;
            const addr = table + (fieldSize * i);
            if (words) {
                value = Memory.getWord(addr);
            }
            else {
                value = Memory.getByte(addr);
            }
            if (x === value) {
                return addr;
            }
        }
        return 0;
    }
    static storeb(array, byteIndex, value) {
        if (isBadArg(array) || isBadArg(byteIndex) || isBadArg(value)) {
            throwBadArg();
        }
        let signedIndex = byteIndex;
        if (signedIndex >= BIT_15) {
            signedIndex -= BIT_16;
        }
        Memory.setByte(array + signedIndex, value);
    }
    static storew(array, wordIndex, value) {
        if (isBadArg(array) || isBadArg(wordIndex) || isBadArg(value)) {
            throwBadArg();
        }
        let signedIndex = wordIndex;
        if (signedIndex >= BIT_15) {
            signedIndex -= BIT_16;
        }
        Memory.setWord(array + (2 * signedIndex), value);
    }
}
