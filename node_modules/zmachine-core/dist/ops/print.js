// OP codes which deal with printing to the output streams are defined here
import Header from '../resources/header';
import Memory from '../state/memory';
import PC from '../state/pc';
import Strings from '../resources/string';
import Objects from '../resources/object';
import Output from '../resources/output';
import Routine from '../resources/routine';
import Status from '../resources/status';
import ZSCII from '../resources/zscii';
import { isBadArg, throwBadArg } from './types';
import { BIT_15, BIT_16 } from '../utils/constants';
function unpackAddress(packedAddressOfString) {
    const version = Header.version();
    if (version === 1 || version === 2 || version === 3) {
        return packedAddressOfString * 2;
    }
    if (version === 4 || version === 5) {
        return packedAddressOfString * 4;
    }
    if (version === 6 || version === 7) {
        const SO = Header.stringOffset();
        return (packedAddressOfString * 4) + (SO * 8);
    }
    if (version === 8) {
        return packedAddressOfString * 8;
    }
    throw new Error(`Unexpected version ${version}`);
}
/* eslint-disable @typescript-eslint/camelcase */
export default class PrintOps {
    static new_line() {
        Output.printFromGame([13]);
    }
    // prints the string at the Program Counter
    static print() {
        const words = [];
        let more = true;
        while (more) {
            const word = PC.readWord();
            words.push(word);
            // eslint-disable-next-line no-bitwise
            if ((word & BIT_15) !== 0) {
                more = false;
            }
        }
        const zsciiCodes = Strings.zsciiFromWords(words);
        Output.printFromGame(zsciiCodes);
    }
    static print_addr(byteAddressOfString) {
        if (isBadArg(byteAddressOfString)) {
            throwBadArg();
        }
        let address = byteAddressOfString;
        const words = [];
        let more = true;
        while (more) {
            const word = Memory.getWord(address);
            address += 2;
            words.push(word);
            // eslint-disable-next-line no-bitwise
            if ((word & BIT_15) !== 0) {
                more = false;
            }
        }
        const zsciiCodes = Strings.zsciiFromWords(words);
        Output.printFromGame(zsciiCodes);
    }
    static print_char(outputCharacterCode) {
        if (isBadArg(outputCharacterCode)) {
            throwBadArg();
        }
        Output.printFromGame([outputCharacterCode]);
    }
    static print_num(value) {
        if (isBadArg(value)) {
            throwBadArg();
        }
        let num = value;
        if (num >= BIT_15) {
            num -= BIT_16;
        }
        const zsciiCodes = num.toString().split('').map((c) => {
            const codePoint = c.charCodeAt(0) || 63;
            return codePoint;
        });
        Output.printFromGame(zsciiCodes);
    }
    static print_obj(object) {
        if (isBadArg(object)) {
            throwBadArg();
        }
        const words = Objects.getNameWords(object);
        const zsciiCodes = Strings.zsciiFromWords(words);
        Output.printFromGame(zsciiCodes);
    }
    static print_paddr(packedAddressOfString) {
        if (isBadArg(packedAddressOfString)) {
            throwBadArg();
        }
        let address = unpackAddress(packedAddressOfString);
        const words = [];
        let more = true;
        while (more) {
            const word = Memory.getWord(address);
            address += 2;
            words.push(word);
            // eslint-disable-next-line no-bitwise
            if ((word & BIT_15) !== 0) {
                more = false;
            }
        }
        const zsciiCodes = Strings.zsciiFromWords(words);
        Output.printFromGame(zsciiCodes);
    }
    static async print_ret() {
        const words = [];
        let more = true;
        while (more) {
            const word = PC.readWord();
            words.push(word);
            // eslint-disable-next-line no-bitwise
            if ((word & BIT_15) !== 0) {
                more = false;
            }
        }
        const zsciiCodes = Strings.zsciiFromWords(words);
        Output.printFromGame(zsciiCodes);
        Output.printFromGame([13]);
        await Routine.return(1);
    }
    static print_table(zsciiText, width, heightArg, skipArg) {
        if (isBadArg(zsciiText) || isBadArg(width)) {
            throwBadArg();
        }
        let height = 1;
        if (heightArg !== null && heightArg > 0) {
            height = heightArg;
        }
        let skip = 0;
        if (skipArg !== null) {
            skip = skipArg;
        }
        const zsciiTable = [];
        for (let i = 0; i < height; i += 1) {
            const row = Memory.getBytes(zsciiText + ((width + skip) * i), width);
            zsciiTable.push(row);
        }
        Output.printTable(zsciiTable);
    }
    static print_unicode(charNumber) {
        if (isBadArg(charNumber)) {
            throwBadArg();
        }
        if (charNumber === 0 || charNumber === 31 || charNumber === 127 || charNumber === 159) {
            throw new Error(`printing illegal unicode value ${charNumber}`);
        }
        Output.printUnicodeFromGame(charNumber);
    }
    static check_unicode(charNumber) {
        if (isBadArg(charNumber)) {
            throwBadArg();
        }
        if (charNumber === 0 || charNumber === 31 || charNumber === 127 || charNumber === 159) {
            return 0;
        }
        const str = String.fromCodePoint(charNumber);
        if (str.length !== 1) {
            return 0;
        }
        if (ZSCII.stringToInputZSCII(str) !== 0) {
            // we can recieve this character as input too
            return 3;
        }
        // this character is output only
        return 1;
    }
    static show_status() {
        const version = Header.version();
        if (version === 3) {
            Status.showStatus();
        }
    }
}
