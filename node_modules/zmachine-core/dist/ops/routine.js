// OP codes which deal with calls and returns from routines are defined here
import Routine from '../resources/routine';
import Variable from '../resources/variable';
import Header from '../resources/header';
import { isBadArg, throwBadArg } from './types';
import { BIT_15, BIT_16, WORD_MASK } from '../utils/constants';
/* eslint-disable @typescript-eslint/camelcase */
export default class RoutineOps {
    static call_vs(routine, arg1, arg2, arg3) {
        if (isBadArg(routine)) {
            throwBadArg();
        }
        const store = true;
        Routine.call(routine, store, arg1, arg2, arg3, null, null, null, null, null);
    }
    static call_vn(routine, arg1, arg2, arg3) {
        if (isBadArg(routine)) {
            throwBadArg();
        }
        const store = false;
        Routine.call(routine, store, arg1, arg2, arg3, null, null, null, null, null);
    }
    static call_vs2(routine, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
        if (isBadArg(routine)) {
            throwBadArg();
        }
        const store = true;
        Routine.call(routine, store, arg1, arg2, arg3, arg4, arg5, arg6, arg7, null);
    }
    static call_vn2(routine, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
        if (isBadArg(routine)) {
            throwBadArg();
        }
        const store = false;
        Routine.call(routine, store, arg1, arg2, arg3, arg4, arg5, arg6, arg7, null);
    }
    static call_1n(routine) {
        if (isBadArg(routine)) {
            throwBadArg();
        }
        // this op code is unusual because it took the place of the not operation in prior versions
        const version = Header.version();
        if (version < 5) {
            // the bitwise not operation
            // eslint-disable-next-line no-bitwise
            const result = WORD_MASK & (~routine);
            // deal with the store part of the instruction here
            Routine.store(result);
            return;
        }
        const store = false;
        Routine.call(routine, store, null, null, null, null, null, null, null, null);
    }
    static call_1s(routine) {
        if (isBadArg(routine)) {
            throwBadArg();
        }
        const store = true;
        Routine.call(routine, store, null, null, null, null, null, null, null, null);
    }
    static call_2s(routine, arg1) {
        if (isBadArg(routine)) {
            throwBadArg();
        }
        const store = true;
        Routine.call(routine, store, arg1, null, null, null, null, null, null, null);
    }
    static call_2n(routine, arg1) {
        if (isBadArg(routine)) {
            throwBadArg();
        }
        const store = false;
        Routine.call(routine, store, arg1, null, null, null, null, null, null, null);
    }
    static catch() {
        // this op code is unusual because it took the place of the pop operation in prior versions
        const version = Header.version();
        if (version < 5) {
            // the pop operation
            Variable.readVar(0);
            return;
        }
        Routine.catch();
    }
    static async throw(value, stackFrame) {
        if (isBadArg(value) || isBadArg(stackFrame)) {
            throwBadArg();
        }
        await Routine.throw(value, stackFrame);
    }
    static jump(label) {
        if (isBadArg(label)) {
            throwBadArg();
        }
        let offset = label;
        if (offset >= BIT_15) {
            offset -= BIT_16;
        }
        Routine.jump(offset - 2);
    }
    static async ret(value) {
        if (isBadArg(value)) {
            throwBadArg();
        }
        await Routine.return(value);
    }
    static async ret_popped() {
        const value = Variable.readVar(0);
        await Routine.return(value);
    }
    static async rfalse() {
        await Routine.return(0);
    }
    static async rtrue() {
        await Routine.return(1);
    }
    static check_arg_count(argumentNumber) {
        if (isBadArg(argumentNumber)) {
            throwBadArg();
        }
        if (Routine.CheckArgumentNumber(argumentNumber)) {
            return 1;
        }
        return 0;
    }
}
