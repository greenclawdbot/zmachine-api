import Memory from '../state/memory';
import Strings from './string';
import Header from './header';
import { BIT_16, BIT_15 } from '../utils/constants';
// compare the encoded input text to the encded text of this entry
function compare(inputWords, entry) {
    for (let i = 0; i < inputWords.length; i += 1) {
        const entryWord = Memory.getWord(entry + (2 * i));
        const inputWord = inputWords[i];
        if (inputWord < entryWord) {
            return -1;
        }
        if (inputWord > entryWord) {
            return 1;
        }
    }
    return 0;
}
function findSortedEntry(inputWords, firstEntry, numEntries, entryLength) {
    let minIndex = 0;
    let maxIndex = numEntries - 1;
    while (minIndex <= maxIndex) {
        const midIndex = Math.floor((minIndex + maxIndex) / 2);
        const midEntry = firstEntry + (midIndex * entryLength);
        const cmp = compare(inputWords, midEntry);
        if (cmp === 0) {
            return midEntry;
        }
        if (cmp < 0) {
            maxIndex = midIndex - 1;
        }
        else {
            minIndex = midIndex + 1;
        }
    }
    return 0;
}
function findUnsortedEntry(inputWords, firstEntry, numEntries, entryLength) {
    for (let i = 0; i < numEntries; i += 1) {
        const entry = firstEntry + (i * entryLength);
        const cmp = compare(inputWords, entry);
        if (cmp === 0) {
            return entry;
        }
    }
    return 0;
}
export default class Dictionary {
    static tokenise(text, parse, dictionary, skipUnknown) {
        const version = Header.version();
        let dictionaryAddr;
        if (dictionary !== null && dictionary > 0) {
            dictionaryAddr = dictionary;
        }
        else {
            dictionaryAddr = Header.dictionaryTable();
        }
        const sepCount = Memory.getByte(dictionaryAddr);
        const seperators = Memory.getBytes(dictionaryAddr + 1, sepCount);
        let index;
        let end;
        if (version < 5) {
            index = text + 1;
            end = index + Memory.getByte(text);
        }
        else {
            index = text + 2;
            end = index + Memory.getByte(text + 1);
        }
        const tokens = [];
        let word = [];
        let start = index;
        while (index < end) {
            const code = Memory.getByte(index);
            index += 1;
            let endWord = false;
            if (code === 0) {
                if (version < 5) {
                    // terminate
                    if (word.length > 0) {
                        endWord = true;
                    }
                    index = end;
                }
                else {
                    throw new Error('unexpected 0 byte in text');
                }
            }
            else if (code === 32) {
                // space
                if (word.length > 0) {
                    endWord = true;
                }
                else {
                    start = index;
                }
            }
            else if (seperators.includes(code)) {
                if (word.length > 0) {
                    // save separator
                    index -= 1;
                    endWord = true;
                }
                else {
                    word.push(code);
                    endWord = true;
                }
            }
            else {
                word.push(code);
            }
            if (index >= end) {
                if (version < 5) {
                    if (code !== 0) {
                        throw new Error('unexpected end of text buffer');
                    }
                }
                else if (word.length > 0) {
                    endWord = true;
                }
            }
            if (endWord) {
                tokens.push({
                    zscii: word,
                    start: start - text,
                });
                word = [];
                start = index;
            }
        }
        // now we have tokens to parse
        this.parse(tokens, parse, dictionary, skipUnknown);
    }
    static parse(tokens, parse, dictionary, skipUnknown) {
        const version = Header.version();
        let dictionaryAddr;
        if (dictionary !== null && dictionary > 0) {
            dictionaryAddr = dictionary;
        }
        else {
            dictionaryAddr = Header.dictionaryTable();
        }
        const sepCount = Memory.getByte(dictionaryAddr);
        const entryLength = Memory.getByte(dictionaryAddr + 1 + sepCount);
        let entryCount = Memory.getWord(dictionaryAddr + 1 + sepCount + 1);
        let sorted = true;
        if (entryCount >= BIT_15) {
            entryCount = BIT_16 - entryCount;
            sorted = false;
        }
        const firstEntry = dictionaryAddr + 1 + sepCount + 1 + 2;
        let wordCount;
        if (version < 4) {
            wordCount = 2;
        }
        else {
            wordCount = 3;
        }
        const maxWords = Memory.getByte(parse);
        Memory.setByte(parse + 1, Math.min(maxWords, tokens.length));
        for (let i = 0; i < tokens.length; i += 1) {
            const { zscii, start } = tokens[i];
            const words = Strings.wordsFromZSCII(zscii, wordCount);
            let entry;
            if (sorted) {
                entry = findSortedEntry(words, firstEntry, entryCount, entryLength);
            }
            else {
                entry = findUnsortedEntry(words, firstEntry, entryCount, entryLength);
            }
            if (entry === 0 && skipUnknown) {
                // write nothing for this parse entry
            }
            else {
                Memory.setWord(parse + 2 + (i * 4), entry);
                Memory.setByte(parse + 2 + (i * 4) + 2, zscii.length);
                Memory.setByte(parse + 2 + (i * 4) + 2 + 1, start);
            }
        }
    }
    static encodeText(zsciiText, length, from, codedText) {
        const zscii = Memory.getBytes(zsciiText + from, length);
        const wordCount = 3;
        const words = Strings.wordsFromZSCII(zscii, wordCount);
        Memory.setWord(codedText, words[0]);
        Memory.setWord(codedText + 2, words[1]);
        Memory.setWord(codedText + 4, words[2]);
    }
    static dump() {
        // dumps the ZSCII for the entries in the dictionary
        const version = Header.version();
        const dictionaryAddr = Header.dictionaryTable();
        const sepCount = Memory.getByte(dictionaryAddr);
        const entryLength = Memory.getByte(dictionaryAddr + 1 + sepCount);
        let entryCount = Memory.getWord(dictionaryAddr + 1 + sepCount + 1);
        if (entryCount >= BIT_15) {
            entryCount = BIT_16 - entryCount;
        }
        const firstEntry = dictionaryAddr + 1 + sepCount + 1 + 2;
        let wordCount;
        if (version < 4) {
            wordCount = 2;
        }
        else {
            wordCount = 3;
        }
        const vocab = [];
        for (let i = 0; i < entryCount; i += 1) {
            const entry = firstEntry + (i * entryLength);
            const words = [];
            for (let j = 0; j < wordCount; j += 1) {
                words.push(Memory.getWord(entry + (2 * j)));
            }
            vocab.push(Strings.zsciiFromWords(words));
        }
        return vocab;
    }
}
