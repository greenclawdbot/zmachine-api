import GameState from '../state/game';
import Memory from '../state/memory';
import Header from './header';
import InputState from '../state/input';
import OutputState from '../state/output';
import PC from '../state/pc';
import Quetzal from './quetzal';
import Random from '../state/random';
import Stack from '../state/stack';
import Screen from './screen';
import ScreenState from '../state/screen';
import { BIT_15 } from '../utils/constants';
const SUPPORTED_VERSIONS = [1, 2, 3, 4, 5, 7, 8];
export default class Game {
    static loadStory(file) {
        GameState.setStoryFile(file);
        InputState.init();
        OutputState.init();
        this.startStory();
    }
    static startStory() {
        // game load and restart but not restore
        const storyFile = GameState.getStoryFile();
        Memory.setMemory(storyFile);
        const version = Header.version();
        if (!SUPPORTED_VERSIONS.includes(version)) {
            throw new Error(`Version ${version} stories are not supported`);
        }
        this.initHeader();
        this.initPC();
        Random.init();
        ScreenState.init();
        Screen.clearScreen();
        Stack.init();
    }
    static initHeader() {
        // should be run on initial load, restarts and restores
        const version = Header.version();
        // set flags1 values
        if (version < 4) {
            // status line not available?
            Header.setFlags1(4, false);
            // screen splitting available?
            Header.setFlags1(5, true);
            // Is a variable pitch font the default?
            Header.setFlags1(6, true);
        }
        else {
            // colors available?
            Header.setFlags1(0, true);
            // pictures displaying available?
            Header.setFlags1(1, false);
            // boldface available?
            Header.setFlags1(2, true);
            // italics available?
            Header.setFlags1(3, true);
            // fixed space style available?
            Header.setFlags1(4, true);
            // sound effects beyond a bleep available?
            Header.setFlags1(5, false);
            // timed keyboard input available?
            Header.setFlags1(7, true);
        }
        // set flags2 values
        // Set when transcripting is on
        Header.setFlags2(0, false);
        // If set, the game wants to use sounds beyond a bleep
        Header.setFlags2(7, false);
        // If set, the game wants to use menus
        Header.setFlags2(8, false);
        // all unused bits in flags3 must be cleared
        for (let i = 0; i < 16; i += 1) {
            Header.setFlags3(i, false);
        }
        // set Interpreter number and version
        // Macintosh
        Memory.setByte(30, 3);
        // R
        Memory.setByte(31, 82);
        // Screen height (chars)
        const { columns, rows } = ScreenState.getScreen();
        Memory.setByte(32, rows);
        // Screen width (chars)
        Memory.setByte(33, columns);
        // Screen height (units)
        Memory.setWord(34, columns);
        // Screen width (units)
        Memory.setWord(36, rows);
        // char dimensions in units
        Memory.setByte(38, 1);
        Memory.setByte(39, 1);
        // default background color (black)
        Memory.setByte(44, 2);
        // default foreground color (white)
        Memory.setByte(45, 9);
        // standard revision 1.1
        Memory.setByte(50, 1);
        Memory.setByte(51, 1);
        // true default foreground color
        const trueForegroundAddr = Header.getHeaderExtensionAddr(5);
        if (trueForegroundAddr !== 0) {
            Memory.setWord(trueForegroundAddr, BIT_15 - 1); // white
        }
        // true default background color
        const trueBackgroundAddr = Header.getHeaderExtensionAddr(6);
        if (trueBackgroundAddr !== 0) {
            Memory.setWord(trueForegroundAddr, 0); // black
        }
    }
    static initPC() {
        const addr = Memory.getWord(6);
        PC.setPC(addr);
    }
    static async saveGame() {
        let success = false;
        // collect game state
        const state = {
            dynamicMemory: Memory.getDynamicMemory(),
            frames: Stack.saveFrames(),
            pc: PC.getPC(),
        };
        const storyFile = GameState.getStoryFile();
        // transform state to bytes in quetzal format
        const saveFile = Quetzal.save(state, storyFile);
        try {
            if (saveFile.length >= 12) {
                await GameState.saveGame(saveFile);
                success = true;
            }
        }
        catch (error) {
            // eslint-disable-next-line no-console
            console.log('Error during save');
            // eslint-disable-next-line no-console
            console.log(error);
        }
        return success;
    }
    static restartGame() {
        const transcriptOn = Header.getFlags2(0);
        const monospaceOn = Header.getFlags2(1);
        this.startStory();
        Header.setFlags2(0, transcriptOn);
        Header.setFlags2(1, monospaceOn);
    }
    static async restoreGame() {
        let success = false;
        try {
            const saveFile = await GameState.loadGame();
            const storyFile = GameState.getStoryFile();
            const { dynamicMemory, frames, pc, } = Quetzal.restore(saveFile, storyFile);
            const transcriptOn = Header.getFlags2(0);
            const monospaceOn = Header.getFlags2(1);
            Memory.setDynamicMemory(dynamicMemory);
            Stack.restoreFrames(frames);
            PC.setPC(pc);
            const version = Header.version();
            if (version === 3) {
                Screen.splitWindow(0);
            }
            this.initHeader();
            Header.setFlags2(0, transcriptOn);
            Header.setFlags2(1, monospaceOn);
            success = true;
        }
        catch (error) {
            // eslint-disable-next-line no-console
            console.log('Error during restore');
            // eslint-disable-next-line no-console
            console.log(error);
        }
        return success;
    }
    static async saveTable(table, bytes, name, doPrompt, doNotPrompt) {
        let success = false;
        const data = Memory.getBytes(table, bytes);
        const nameLength = Memory.getByte(name);
        const nameBytes = Memory.getBytes(name + 1, nameLength);
        const fileName = this.auxFileName(nameBytes);
        try {
            await GameState.saveTable(data, fileName, doPrompt, doNotPrompt);
            success = true;
        }
        catch (error) {
            // eslint-disable-next-line no-console
            console.log('Error during saveTable');
            // eslint-disable-next-line no-console
            console.log(error);
        }
        return success;
    }
    static async restoreTable(table, bytes, name, doPrompt, doNotPrompt) {
        let bytesRestored = 0;
        const nameLength = Memory.getByte(name);
        const nameBytes = Memory.getBytes(name + 1, nameLength);
        const fileName = this.auxFileName(nameBytes);
        try {
            const data = await GameState.loadTable(fileName, doPrompt, doNotPrompt);
            if (data.length <= bytes) {
                Memory.setBytes(table, data);
                bytesRestored = data.length;
            }
            else {
                throw new Error('more bytes restored than expected');
            }
        }
        catch (error) {
            // eslint-disable-next-line no-console
            console.log('Error during restoreTable');
            // eslint-disable-next-line no-console
            console.log(error);
        }
        return bytesRestored;
    }
    static auxFileName(nameBytes) {
        let name = '';
        let stop = false;
        for (let i = 0; i < nameBytes.length && name.length < 8 && !stop; i += 1) {
            const byte = nameBytes[i];
            if (byte === 46) {
                stop = true;
            }
            else if (byte >= 48 && byte < 58) {
                // number
                name += String.fromCharCode(byte);
            }
            else if (byte >= 65 && byte < 91) {
                // A-Z
                name += String.fromCharCode(byte);
            }
            else if (byte >= 97 && byte < 123) {
                // a-z
                name += String.fromCharCode(byte - 32);
            }
        }
        if (name.length === 0) {
            name = 'NULL';
        }
        name += '.AUX';
        return name;
    }
    static saveUndo() {
        // collect game state
        const state = {
            dynamicMemory: Memory.getDynamicMemory(),
            frames: Stack.saveFrames(),
            pc: PC.getPC(),
        };
        GameState.pushUndo(state);
        return true;
    }
    static restoreUndo() {
        const undo = GameState.popUndo();
        if (undo === null) {
            return false;
        }
        const { dynamicMemory, frames, pc, } = undo;
        const transcriptOn = Header.getFlags2(0);
        const monospaceOn = Header.getFlags2(1);
        Memory.setDynamicMemory(dynamicMemory);
        Stack.restoreFrames(frames);
        PC.setPC(pc);
        this.initHeader();
        Header.setFlags2(0, transcriptOn);
        Header.setFlags2(1, monospaceOn);
        return true;
    }
    static verifyChecksum() {
        const checksum = Header.checksum();
        return checksum === GameState.checksum();
    }
}
