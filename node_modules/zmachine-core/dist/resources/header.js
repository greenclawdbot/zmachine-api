import Memory from '../state/memory';
import { BITS } from '../utils/constants';
export default class Header {
    static version() {
        return Memory.getByte(0);
    }
    static getFlags1(bit) {
        if (bit < 0 || bit >= 8) {
            throw new Error('bit out of range in getFlags1');
        }
        const byte = Memory.getByte(1);
        // eslint-disable-next-line no-bitwise
        return (byte & BITS[bit]) !== 0;
    }
    static setFlags1(bit, value) {
        if (bit < 0 || bit >= 8) {
            throw new Error('bit out of range in setFlags1');
        }
        const byte = Memory.getByte(1);
        if (value) {
            // eslint-disable-next-line no-bitwise
            Memory.setByte(1, byte | BITS[bit]);
        }
        else {
            // eslint-disable-next-line no-bitwise
            Memory.setByte(1, byte & ~BITS[bit]);
        }
    }
    static dictionaryTable() {
        return Memory.getWord(8);
    }
    static objectTable() {
        return Memory.getWord(10);
    }
    static globalVarTable() {
        return Memory.getWord(12);
    }
    static getFlags2(bit) {
        if (bit < 0 || bit >= 16) {
            throw new Error('bit out of range in getFlags2');
        }
        const word = Memory.getWord(16);
        // eslint-disable-next-line no-bitwise
        return (word & BITS[bit]) !== 0;
    }
    static setFlags2(bit, value) {
        if (bit < 0 || bit >= 16) {
            throw new Error('bit out of range in setFlags2');
        }
        const word = Memory.getWord(16);
        if (value) {
            // eslint-disable-next-line no-bitwise
            Memory.setWord(16, word | BITS[bit]);
        }
        else {
            // eslint-disable-next-line no-bitwise
            Memory.setWord(16, word & ~BITS[bit]);
        }
    }
    static abbreviationTable() {
        return Memory.getWord(24);
    }
    static fileLength() {
        const version = this.version();
        const lengthWord = Memory.getWord(26);
        if (version < 4) {
            return 2 * lengthWord;
        }
        if (version < 6) {
            return 4 * lengthWord;
        }
        return 8 * lengthWord;
    }
    static checksum() {
        return Memory.getWord(28);
    }
    static routineOffset() {
        return Memory.getWord(40);
    }
    static stringOffset() {
        return Memory.getWord(42);
    }
    static terminatingCharactersTable() {
        return Memory.getWord(46);
    }
    // returns the byte address of the word or 0 if the word is not in table
    static getHeaderExtensionAddr(wordNum) {
        if (wordNum < 1) {
            throw new Error('wordNum out of range in getHeaderExtensionAddr');
        }
        const headerExtentionTableAddr = Memory.getWord(54);
        if (headerExtentionTableAddr === 0) {
            return 0;
        }
        const tableLength = Memory.getWord(headerExtentionTableAddr);
        if (wordNum > tableLength) {
            return 0;
        }
        return headerExtentionTableAddr + (2 * wordNum);
    }
    static getFlags3(bit) {
        if (bit < 0 || bit >= 16) {
            throw new Error('bit out of range in getFlags3');
        }
        const addr = this.getHeaderExtensionAddr(4);
        if (addr > 0) {
            const word = Memory.getWord(addr);
            // eslint-disable-next-line no-bitwise
            return (word & BITS[bit]) !== 0;
        }
        return false;
    }
    static setFlags3(bit, value) {
        if (bit < 0 || bit >= 16) {
            throw new Error('bit out of range in setFlags3');
        }
        const addr = this.getHeaderExtensionAddr(4);
        if (addr > 0) {
            const word = Memory.getWord(addr);
            if (value) {
                // eslint-disable-next-line no-bitwise
                Memory.setWord(addr, word | BITS[bit]);
            }
            else {
                // eslint-disable-next-line no-bitwise
                Memory.setWord(addr, word & ~BITS[bit]);
            }
        }
    }
    static alphabetTable() {
        return Memory.getWord(52);
    }
}
