import Dictionary from './dictionary';
import GameState from '../state/game';
import Header from './header';
import InputState, { FILE_STREAM, KEYBOARD_STREAM } from '../state/input';
import Memory from '../state/memory';
import Output from './output';
import Routine from './routine';
import ZSCII from './zscii';
const END_OF_FILE = 'End of file';
function makeTimer(timeMilliseconds) {
    return new Promise((resolve) => {
        setTimeout(resolve, timeMilliseconds, 0);
    });
}
export default class Input {
    static async untimedRead(text, parse) {
        const terminator = await this.read(text);
        this.finishRead(text, parse, terminator);
    }
    static async timedRead(text, parse, time, routine, resuming = false, casedInput = [], resumeValue = 0) {
        if (resuming) {
            if (resumeValue !== 0) {
                // erase input and terminate with value 0
                Memory.setByte(text + 1, 0);
                this.finishRead(text, parse, 0);
                return;
            }
            if (casedInput.length > 0) {
                const codes = Output.getInputBeforeCursor(casedInput.length);
                let redo = false;
                if (codes.length === casedInput.length) {
                    for (let i = 0; i < casedInput.length; i += 1) {
                        if (codes[i] !== casedInput[i]) {
                            redo = true;
                        }
                    }
                }
                else {
                    redo = true;
                }
                if (redo) {
                    for (let i = 0; i < casedInput.length; i += 1) {
                        Output.printFromMidRead(casedInput[i]);
                    }
                }
            }
        }
        const timer = makeTimer(time * 100);
        const terminator = await this.read(text, timer, casedInput);
        if (terminator === 0) {
            // call interrupt routine and later resume via a callback to this method
            const store = false;
            const callback = (returnValue) => (this.timedRead(text, parse, time, routine, true, casedInput, returnValue));
            Routine.call(routine, store, null, null, null, null, null, null, null, callback);
        }
        else {
            this.finishRead(text, parse, terminator);
        }
    }
    static finishRead(text, parse, terminator) {
        const version = Header.version();
        if (parse !== 0) {
            Dictionary.tokenise(text, parse, 0, false);
        }
        if (version >= 5) {
            Routine.store(terminator);
        }
    }
    static getTerminatingCharacters() {
        const version = Header.version();
        const terminatingCharacters = [];
        if (version >= 5) {
            const table = Header.terminatingCharactersTable();
            if (table > 0) {
                let i = 0;
                let more = true;
                while (more) {
                    const code = Memory.getByte(table + i);
                    if (code === 0) {
                        more = false;
                    }
                    else if (code === 255) {
                        for (let funcCode = 129; funcCode < 155; funcCode += 1) {
                            terminatingCharacters.push(funcCode);
                        }
                        terminatingCharacters.push(252);
                        terminatingCharacters.push(253);
                        terminatingCharacters.push(254);
                    }
                    else {
                        terminatingCharacters.push(code);
                        i += 1;
                    }
                }
            }
        }
        return terminatingCharacters;
    }
    static async read(text, timer = null, casedInput = []) {
        const version = Header.version();
        let maxInputLength;
        if (version < 5) {
            maxInputLength = Memory.getByte(text) - 1;
        }
        else {
            maxInputLength = Memory.getByte(text);
            const inputLength = Memory.getByte(text + 1);
            const buffer = Memory.getBytes(text + 2, inputLength);
            let inputGood = false;
            if (inputLength === casedInput.length) {
                // check that they match
                inputGood = true;
                for (let i = 0; i < inputLength; i += 1) {
                    let lowerCaseCode = casedInput[i];
                    if (lowerCaseCode >= 65 && lowerCaseCode <= 90) {
                        lowerCaseCode += 32;
                    }
                    if (lowerCaseCode !== buffer[i]) {
                        inputGood = false;
                    }
                }
            }
            if (!inputGood) {
                // we are likely starting with previously typed input (not from an interrupt)
                // try to get the cased input from the screen
                while (casedInput.length > 0) {
                    casedInput.pop();
                }
                const codes = Output.getInputBeforeCursor(inputLength);
                for (let i = 0; i < inputLength; i += 1) {
                    const casedCode = codes[i] || 0;
                    let lowerCaseCode = casedCode;
                    if (lowerCaseCode >= 65 && lowerCaseCode <= 90) {
                        lowerCaseCode += 32;
                    }
                    if (lowerCaseCode === buffer[i]) {
                        casedInput.push(casedCode);
                    }
                    else {
                        casedInput.push(buffer[i]);
                    }
                }
            }
        }
        const terminator = await this.readInput(casedInput, maxInputLength, timer);
        // fill text buffer to match casedInput
        if (version < 5) {
            for (let i = 0; i < casedInput.length; i += 1) {
                let lowerCaseChar = casedInput[i];
                if (lowerCaseChar >= 65 && lowerCaseChar <= 90) {
                    lowerCaseChar += 32;
                }
                Memory.setByte(text + 1 + i, lowerCaseChar);
            }
            Memory.setByte(text + 1 + casedInput.length, 0);
        }
        else {
            for (let i = 0; i < casedInput.length; i += 1) {
                let lowerCaseChar = casedInput[i];
                if (lowerCaseChar >= 65 && lowerCaseChar <= 90) {
                    lowerCaseChar += 32;
                }
                Memory.setByte(text + 2 + i, lowerCaseChar);
            }
            Memory.setByte(text + 1, casedInput.length);
        }
        return terminator;
    }
    static async readInput(inputBuffer, // modified in place
    maxInputLength, timer) {
        Output.flushBeforeInput();
        const terminatingCharacters = this.getTerminatingCharacters();
        let terminator = null;
        if (InputState.getActiveStream() === FILE_STREAM) {
            try {
                const [command, code] = await this.replayCommand();
                if (command.length > maxInputLength) {
                    throw new Error('unexpected command in readChar');
                }
                // copy command to inputBuffer and screen
                for (let i = 0; i < command.length; i += 1) {
                    if (i < inputBuffer.length) {
                        if (command[i] !== inputBuffer[i]) {
                            while (i < inputBuffer.length) {
                                // backspace until they match
                                Output.printFromMidRead(8);
                                inputBuffer.pop();
                            }
                        }
                    }
                    if (inputBuffer.length === i) {
                        // type this character
                        Output.printFromMidRead(command[i]);
                        inputBuffer.push(command[i]);
                    }
                }
                if (code === 13) {
                    // Enter
                    Output.printFromMidRead(code);
                }
                terminator = code;
            }
            catch (err) {
                if (err && err.message) {
                    if (err.message !== END_OF_FILE) {
                        // eslint-disable-next-line no-console
                        console.log(`switching off file input due to error: ${err.message}`);
                    }
                }
                else {
                    // eslint-disable-next-line no-console
                    console.log('switching off file input due to error');
                    // eslint-disable-next-line no-console
                    console.log(err);
                }
                InputState.setActiveStream(KEYBOARD_STREAM);
            }
        }
        while (terminator === null) {
            // eslint-disable-next-line no-await-in-loop
            const code = await InputState.readKeyPress(timer);
            if (code === 0) {
                // interrupted by timer
                terminator = code;
            }
            else if (code === 13) {
                // Enter
                Output.printFromMidRead(code);
                terminator = code;
            }
            else if (terminatingCharacters.includes(code)) {
                terminator = code;
            }
            else if (code === 8) {
                // Backspace
                if (inputBuffer.length > 0) {
                    Output.printFromMidRead(code);
                    inputBuffer.pop();
                }
            }
            else if ((code >= 32 && code < 127) || (code >= 155 && code < 252)) {
                // valid output code
                if (inputBuffer.length < maxInputLength) {
                    Output.printFromMidRead(code);
                    inputBuffer.push(code);
                }
            }
        }
        Output.printFromReadEnd(inputBuffer, terminator);
        return terminator;
    }
    static async timedReadChar(time, routine, resuming = false, resumeValue = 0) {
        if (resuming) {
            if (resumeValue !== 0) {
                Routine.store(0);
                return;
            }
        }
        const timer = makeTimer(time * 100);
        const code = await this.readChar(timer);
        if (code === 0) {
            // call interrupt routine and later resume via a callback to this method
            const store = false;
            const callback = (returnValue) => (this.timedReadChar(time, routine, true, returnValue));
            Routine.call(routine, store, null, null, null, null, null, null, null, callback);
        }
        else {
            Routine.store(code);
        }
    }
    static async untimedReadChar() {
        const code = await this.readChar(null);
        Routine.store(code);
    }
    static async readChar(timer) {
        Output.flushBeforeInput();
        let terminator = null;
        if (InputState.getActiveStream() === FILE_STREAM) {
            try {
                const [command, code] = await this.replayCommand();
                if (command.length > 0) {
                    throw new Error('unexpected command in readChar');
                }
                terminator = code;
            }
            catch (err) {
                if (err && err.message) {
                    if (err.message !== END_OF_FILE) {
                        // eslint-disable-next-line no-console
                        console.log(`switching off file input due to error: ${err.message}`);
                    }
                }
                else {
                    // eslint-disable-next-line no-console
                    console.log('switching off file input due to error');
                    // eslint-disable-next-line no-console
                    console.log(err);
                }
                InputState.setActiveStream(KEYBOARD_STREAM);
            }
        }
        if (terminator === null) {
            terminator = await InputState.readKeyPress(timer);
        }
        Output.printFromReadChar(terminator);
        return terminator;
    }
    static async replayCommand() {
        const escaped = await GameState.replayCommand();
        if (escaped === null) {
            throw new Error(END_OF_FILE);
        }
        return this.unescapeCommand(escaped);
    }
    static unescapeCommand(escaped) {
        const command = [];
        let i = 0;
        let terminator = 13;
        while (i < escaped.length) {
            const c = escaped[i];
            i += 1;
            if (c === '\\') {
                if (i < escaped.length && escaped[i] === '\\') {
                    i += 1;
                    command.push(ZSCII.stringToInputZSCII('\\'));
                }
                else if (escaped[i] === 'x' && i + 3 === escaped.length) {
                    // this is an escaped terminating character
                    terminator = Number.parseInt(escaped.slice(i, i + 2), 16);
                    i += 3;
                    if (Number.isNaN(terminator)) {
                        throw new Error(`Malformed terminating escape sequence in command ${escaped}`);
                    }
                }
                else {
                    throw new Error(`Unexpected escape sequence in command ${escaped}`);
                }
            }
            else {
                const code = ZSCII.stringToInputZSCII(c);
                if (code === 0) {
                    throw new Error('non-input character in command');
                }
                command.push(code);
            }
        }
        return [command, terminator];
    }
    // returns true if this keypress could be converted
    // to a input ZSCII code
    static keyPress(keyPress) {
        const code = ZSCII.stringToInputZSCII(keyPress);
        if (code !== 0) {
            InputState.keyPress(code);
            return true;
        }
        return false;
    }
}
