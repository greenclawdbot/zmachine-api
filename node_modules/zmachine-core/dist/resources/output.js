import OutputState from '../state/output';
import GameState from '../state/game';
import Header from './header';
import Memory from '../state/memory';
import Screen from './screen';
import ZSCII from './zscii';
export default class Output {
    static setStream1(active) {
        OutputState.stream1 = active;
    }
    static getStream1() {
        return OutputState.stream1;
    }
    static setStream2(active) {
        Header.setFlags2(0, active);
    }
    static getStream2() {
        return Header.getFlags2(0);
    }
    static startStream3(table) {
        if (OutputState.stream3.length >= 16) {
            throw new Error('stream three stack overflow');
        }
        OutputState.stream3.push({
            table,
            count: 0,
        });
    }
    static endStream3() {
        const buffer = OutputState.stream3.pop();
        if (buffer === undefined) {
            throw new Error('stream three stack underflow');
        }
        Memory.setWord(buffer.table, buffer.count);
    }
    static setStream4(active) {
        OutputState.stream4 = active;
    }
    static getStream4() {
        return OutputState.stream4;
    }
    static printFromGame(zscii) {
        if (OutputState.stream3.length > 0) {
            const index = OutputState.stream3.length - 1;
            const { table, count } = OutputState.stream3[index];
            Memory.setBytes(table + 2 + count, zscii);
            OutputState.stream3[index].count += zscii.length;
        }
        else {
            if (this.getStream1()) {
                Screen.printZSCII(zscii);
            }
            if (this.getStream2()) {
                const text = ZSCII.outputZSCIIToString(zscii);
                this.writeToTranscript(text);
            }
        }
    }
    static writeToTranscript(text) {
        if (Screen.getWindow() === 'LOWER') {
            // the spec seems to indicate that all printing to any window
            // should be echoed to the transcript,
            // but some games behave as if only the lower window does
            const lines = text.split('\n');
            let line = OutputState.transcriptBuffer + (lines.shift() || '');
            while (lines.length > 0) {
                GameState.writeTranscriptLine(line);
                line = lines.shift() || '';
            }
            OutputState.transcriptBuffer = line;
        }
    }
    static escapeCommand(command, terminator) {
        const escaped = command.split('').map((c) => {
            if (c === '\\') {
                return '\\\\';
            }
            return c;
        }).join('');
        if (terminator === 13) {
            return escaped;
        }
        // encode the terminator code as a hex number \xx
        return `${escaped}\\x${terminator.toString(16).padStart(2, '0')}`;
    }
    static recordCommand(zscii, terminator) {
        const command = ZSCII.outputZSCIIToString(zscii);
        const escaped = this.escapeCommand(command, terminator);
        GameState.recordCommand(escaped);
    }
    static printUnicodeFromGame(charCode) {
        if (OutputState.stream3.length > 0) {
            const index = OutputState.stream3.length - 1;
            const { table, count } = OutputState.stream3[index];
            let code = charCode;
            if (code < 32 || code >= 127) {
                code = ZSCII.lookupExtraCharacter(code);
                if (code === 0) {
                    code = 63; // question mark
                }
            }
            Memory.setByte(table + 2 + count, code);
            OutputState.stream3[index].count += 1;
        }
        else {
            if (this.getStream1()) {
                let str = String.fromCodePoint(charCode);
                if (str.length !== 1) {
                    str = '?';
                }
                Screen.printString(str);
            }
            if (this.getStream2()) {
                let str = String.fromCodePoint(charCode);
                if (str.length !== 1) {
                    str = '?';
                }
                this.writeToTranscript(str);
            }
        }
    }
    static printTable(zsciiTable) {
        if (OutputState.stream3.length > 0) {
            if (zsciiTable.length === 1) {
                this.printFromGame(zsciiTable[0]);
                return;
            }
            throw new Error('printTable to stream 3');
        }
        else {
            if (this.getStream1()) {
                Screen.printTable(zsciiTable);
            }
            if (this.getStream2()) {
                const text = zsciiTable.map((row) => ZSCII.outputZSCIIToString(row)).join('\n');
                this.writeToTranscript(text);
            }
        }
    }
    static printFromMidRead(code) {
        if (this.getStream1()) {
            if (code === 8) {
                Screen.backspace();
            }
            else {
                Screen.printZSCII([code]);
            }
            this.flushBuffer();
        }
    }
    static printFromReadEnd(zscii, terminator) {
        if (this.getStream2()) {
            this.writeToTranscript(ZSCII.outputZSCIIToString(zscii));
            this.writeToTranscript('\n');
        }
        if (this.getStream4()) {
            this.recordCommand(zscii, terminator);
        }
    }
    static printFromReadChar(zscii) {
        // this only has an effect of stream 4
        if (this.getStream4()) {
            this.recordCommand([], zscii);
        }
    }
    static makeNoise(noiseType) {
        GameState.makeNoise(noiseType);
    }
    static getInputBeforeCursor(length) {
        // used for comparing to input after a timed interrupt
        return Screen.getInputBeforeCursor(length);
    }
    static flushBuffer() {
        Screen.flush();
    }
    static flushBeforeInput() {
        Screen.flushBeforeInput();
    }
}
