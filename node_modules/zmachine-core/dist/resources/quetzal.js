import { BIT_4, BIT_8, BIT_16, BIT_24, BIT_32, BYTE_MASK_0, } from '../utils/constants';
import { calculateChecksum } from '../utils/methods';
export default class Quetzal {
    static save(state, storyFile) {
        // collect chunks (IFhd, UMem, Stks)
        const chunkIFhd = this.chunkIFhd(storyFile, state.pc);
        const chunkCMem = this.chunkCMem(state.dynamicMemory, storyFile);
        const chunkStks = this.chunkStks(state.frames);
        // concatenate chunks
        const data = [
            ...this.idToBytes('IFZS'),
            ...chunkIFhd,
            ...chunkCMem,
            ...chunkStks,
        ];
        // produce IFZS chunk
        return this.chunk('FORM', data);
    }
    static restore(saveFile, storyFile) {
        if (saveFile.length < 12) {
            throw new Error(`save file too short ${saveFile.length}`);
        }
        let { id, data, remainder, } = this.unchunk(saveFile);
        if (id !== 'FORM') {
            throw new Error(`unexpected ID ${id} !== FORM`);
        }
        const subID = String.fromCharCode(...data.slice(0, 4));
        if (subID !== 'IFZS') {
            throw new Error(`unexpected subID ${subID} !== IFZS`);
        }
        remainder = data.slice(4);
        let dynamicMemory = null;
        let pc = null;
        let frames = null;
        while (remainder.length >= 8) {
            ({ id, data, remainder } = this.unchunk(remainder));
            if (id === 'UMem' && dynamicMemory === null) {
                dynamicMemory = data;
            }
            if (id === 'CMem' && dynamicMemory === null) {
                dynamicMemory = this.unpackCMem(data, storyFile);
            }
            if (id === 'IFhd' && pc === null) {
                pc = this.unpackIFhd(data, storyFile);
            }
            if (id === 'Stks' && frames === null) {
                frames = this.unpackStks(data);
            }
        }
        if (dynamicMemory === null) {
            throw new Error('save file did contain memory chunk');
        }
        if (pc === null) {
            throw new Error('save file did contain header chunk');
        }
        if (frames === null) {
            throw new Error('save file did contain stack chunk');
        }
        return {
            dynamicMemory,
            pc,
            frames,
        };
    }
    static chunk(id, data) {
        // produce an IFF chunk
        let extraByte = [];
        if (data.length % 2 === 1) {
            extraByte = [0];
        }
        return [
            ...this.idToBytes(id),
            ...this.int32ToBytes(data.length),
            ...data,
            ...extraByte,
        ];
    }
    static unchunk(file) {
        // unpack an IFF chunk from the front of this file
        if (file.length < 8) {
            throw new Error(`chunk length is too short ${file.length}`);
        }
        if (file[0] < 32 || file[0] > 126
            || file[1] < 32 || file[1] > 126
            || file[2] < 32 || file[2] > 126
            || file[3] < 32 || file[3] > 126) {
            throw new Error(`illegal chunk id ${file.slice(0, 4)}`);
        }
        const id = String.fromCharCode(...file.slice(0, 4));
        const length = this.bytesToInt32(file.slice(4, 8));
        let extraByte = 0;
        if (length % 2 === 1) {
            extraByte = 1;
        }
        if (8 + length + extraByte > file.length) {
            throw new Error('chunk in excess of file length');
        }
        return {
            id,
            data: file.slice(8, 8 + length),
            remainder: file.slice(8 + length + extraByte),
        };
    }
    static chunkCMem(dynamicMemory, storyFile) {
        const len = (storyFile[14] * 256) + storyFile[15];
        if (dynamicMemory.length !== len) {
            throw new Error('unexpected dynamic memory length');
        }
        if (storyFile.length < len) {
            throw new Error('unexpected story file length');
        }
        const data = [];
        let zeroRunLength = 0;
        for (let i = 0; i < len; i += 1) {
            const xorByte = dynamicMemory[i] ^ storyFile[i];
            if (xorByte === 0) {
                zeroRunLength += 1;
            }
            else {
                if (zeroRunLength > 0) {
                    // output run of zeros
                    while (zeroRunLength > 256) {
                        data.push(0, 255);
                        zeroRunLength -= 256;
                    }
                    data.push(0, zeroRunLength - 1);
                    zeroRunLength = 0;
                }
                data.push(xorByte);
            }
        }
        return this.chunk('CMem', data);
    }
    static unpackCMem(data, storyFile) {
        const len = (storyFile[14] * 256) + storyFile[15];
        if (storyFile.length < len) {
            throw new Error('unexpected story file length');
        }
        const dynamicMemory = [];
        let i = 0;
        let j = 0;
        while (i < data.length) {
            const xorByte = data[i];
            i += 1;
            if (xorByte === 0) {
                if (i < data.length) {
                    const runLength = data[i] + 1;
                    i += 1;
                    if (j + runLength > len) {
                        throw new Error('decompressed more bytes than expected');
                    }
                    dynamicMemory.push(...storyFile.slice(j, j + runLength));
                    j += runLength;
                }
                else {
                    throw new Error('unexpected incomplete run of zeros');
                }
            }
            else {
                if (j >= len) {
                    throw new Error('decompressed more bytes than expected');
                }
                dynamicMemory.push(storyFile[j] ^ xorByte);
                j += 1;
            }
        }
        if (j < len) {
            dynamicMemory.push(...storyFile.slice(j, len));
        }
        return dynamicMemory;
    }
    static chunkStks(frames) {
        const data = [];
        for (let i = 0; i < frames.length; i += 1) {
            const frame = frames[i];
            let { storeVar } = frame;
            let flags = frame.locals.length;
            if (!frame.store) {
                flags += BIT_4;
                storeVar = 0;
            }
            data.push(...this.int24ToBytes(frame.returnPC), flags, storeVar, frame.argFlags, ...this.int16ToBytes(frame.stack.length));
            for (let j = 0; j < frame.locals.length; j += 1) {
                data.push(...this.int16ToBytes(frame.locals[j]));
            }
            for (let j = 0; j < frame.stack.length; j += 1) {
                data.push(...this.int16ToBytes(frame.stack[j]));
            }
        }
        return this.chunk('Stks', data);
    }
    static unpackStks(data) {
        const frames = [];
        let i = 0;
        while (i < data.length) {
            // read a frame
            if (i + 8 > data.length) {
                throw new Error('incomplete frame');
            }
            const returnPC = this.bytesToInt24(data.slice(i, i + 3));
            const flags = data[i + 3];
            let numLocals = flags;
            let store = true;
            if (flags >= BIT_4) {
                store = false;
                numLocals -= BIT_4;
            }
            const storeVar = data[i + 4];
            const argFlags = data[i + 5];
            const numStack = this.bytesToInt16(data.slice(i + 6, i + 8));
            i += 8;
            const locals = [];
            while (locals.length < numLocals) {
                if (i + 2 > data.length) {
                    throw new Error('incomplete locals');
                }
                locals.push(this.bytesToInt16(data.slice(i, i + 2)));
                i += 2;
            }
            const stack = [];
            while (stack.length < numStack) {
                if (i + 2 > data.length) {
                    throw new Error('incomplete stack');
                }
                stack.push(this.bytesToInt16(data.slice(i, i + 2)));
                i += 2;
            }
            const interruptCallback = null;
            frames.push({
                returnPC,
                store,
                storeVar,
                locals,
                stack,
                argFlags,
                interruptCallback,
            });
        }
        return frames;
    }
    static chunkIFhd(file, pc) {
        const checksumWord = calculateChecksum(file);
        const data = [
            file[2], file[3],
            file[18], file[19], file[20], file[21], file[22], file[23],
            ...this.int16ToBytes(checksumWord),
            ...this.int24ToBytes(pc),
        ];
        return this.chunk('IFhd', data);
    }
    static unpackIFhd(data, file) {
        if (data.length !== 13) {
            throw new Error(`Unexpected IFhd length ${data.length}`);
        }
        if (file.length < 30) {
            throw new Error(`Unexpected file length ${file.length}`);
        }
        if (data[0] !== file[2] || data[1] !== file[3]) {
            throw new Error('Release number mismatch');
        }
        if (data[2] !== file[18]
            || data[3] !== file[19]
            || data[4] !== file[20]
            || data[5] !== file[21]
            || data[6] !== file[22]
            || data[7] !== file[23]) {
            throw new Error('Serial number mismatch');
        }
        const checksumWord = calculateChecksum(file);
        const checksumBytes = this.int16ToBytes(checksumWord);
        if (data[8] !== checksumBytes[0] || data[9] !== checksumBytes[1]) {
            throw new Error('Checksum mismatch');
        }
        const pc = this.bytesToInt24(data.slice(10, 13));
        return pc;
    }
    static idToBytes(id) {
        if (id.length !== 4) {
            throw new Error(`unexpected id length ${id}`);
        }
        return [
            (id.charCodeAt(0) || 63) & BYTE_MASK_0,
            (id.charCodeAt(1) || 63) & BYTE_MASK_0,
            (id.charCodeAt(2) || 63) & BYTE_MASK_0,
            (id.charCodeAt(3) || 63) & BYTE_MASK_0,
        ];
    }
    static int32ToBytes(num) {
        if (num < 0 || num >= BIT_32) {
            throw new Error(`unexpected number ${num}`);
        }
        let remainder = num;
        const byte0 = remainder & BYTE_MASK_0;
        remainder = (remainder - byte0) / BIT_8;
        const byte1 = remainder & BYTE_MASK_0;
        remainder = (remainder - byte1) / BIT_8;
        const byte2 = remainder & BYTE_MASK_0;
        remainder = (remainder - byte2) / BIT_8;
        const byte3 = remainder & BYTE_MASK_0;
        return [
            byte3,
            byte2,
            byte1,
            byte0,
        ];
    }
    static bytesToInt32(bytes) {
        if (bytes.length !== 4) {
            throw new Error(`unexpected bytes length ${bytes.length}`);
        }
        return (bytes[0] * BIT_24) + (bytes[1] * BIT_16) + (bytes[2] * BIT_8) + bytes[3];
    }
    static int24ToBytes(num) {
        if (num < 0 || num >= BIT_24) {
            throw new Error(`unexpected number ${num}`);
        }
        let remainder = num;
        const byte0 = remainder & BYTE_MASK_0;
        remainder = (remainder - byte0) / BIT_8;
        const byte1 = remainder & BYTE_MASK_0;
        remainder = (remainder - byte1) / BIT_8;
        const byte2 = remainder & BYTE_MASK_0;
        return [
            byte2,
            byte1,
            byte0,
        ];
    }
    static bytesToInt24(bytes) {
        if (bytes.length !== 3) {
            throw new Error(`unexpected bytes length ${bytes.length}`);
        }
        return (bytes[0] * BIT_16) + (bytes[1] * BIT_8) + bytes[2];
    }
    static int16ToBytes(num) {
        if (num < 0 || num >= BIT_16) {
            throw new Error(`unexpected number ${num}`);
        }
        let remainder = num;
        const byte0 = remainder & BYTE_MASK_0;
        remainder = (remainder - byte0) / BIT_8;
        const byte1 = remainder & BYTE_MASK_0;
        return [
            byte1,
            byte0,
        ];
    }
    static bytesToInt16(bytes) {
        if (bytes.length !== 2) {
            throw new Error(`unexpected bytes length ${bytes.length}`);
        }
        return (bytes[0] * BIT_8) + bytes[1];
    }
}
