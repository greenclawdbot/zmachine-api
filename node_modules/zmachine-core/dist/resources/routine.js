// OP codes which deal with calls and returns from routines are defined here
import Stack from '../state/stack';
import PC from '../state/pc';
import Header from './header';
import Variable from './variable';
import { BIT_0, BIT_1, BIT_2, BIT_3, BIT_4, BIT_5, BIT_6, BIT_7, BIT_13, BIT_14, BIT_16, BITS, } from '../utils/constants';
function unpackAddress(routine) {
    const version = Header.version();
    if (version === 1 || version === 2 || version === 3) {
        return routine * 2;
    }
    if (version === 4 || version === 5) {
        return routine * 4;
    }
    if (version === 6 || version === 7) {
        const RO = Header.routineOffset();
        return (routine * 4) + (RO * 8);
    }
    if (version === 8) {
        return routine * 8;
    }
    throw new Error(`Unexpected version ${version}`);
}
export default class Routine {
    static async branch(value) {
        let branch = value === 0;
        const byte = PC.readByte();
        // eslint-disable-next-line no-bitwise
        if (byte & BIT_7) {
            branch = !branch;
        }
        let offset;
        // eslint-disable-next-line no-bitwise
        if (byte & BIT_6) {
            // eslint-disable-next-line no-bitwise
            offset = byte & 63;
        }
        else {
            const byte2 = PC.readByte();
            // eslint-disable-next-line no-bitwise
            offset = ((byte & 63) << 8) + byte2;
            if (offset >= BIT_13) {
                offset -= BIT_14;
            }
        }
        if (branch) {
            if (offset === 0 || offset === 1) {
                await this.return(offset);
            }
            else {
                this.jump(offset - 2);
            }
        }
    }
    static call(routine, store, arg1, arg2, arg3, arg4, arg5, arg6, arg7, interruptCallback) {
        let storeVar = 0;
        if (store) {
            storeVar = PC.readByte();
        }
        if (routine === 0) {
            if (store) {
                Variable.writeVar(storeVar, 0);
            }
            return;
        }
        const newPC = unpackAddress(routine);
        const returnPC = PC.getPC();
        PC.setPC(newPC);
        const numLocals = PC.readByte();
        if (numLocals < 0 || numLocals > 15) {
            throw new Error(`numLocals out of range ${numLocals}`);
        }
        const locals = [];
        const version = Header.version();
        if (version < 5) {
            for (let i = 0; i < numLocals; i += 1) {
                locals.push(PC.readWord());
            }
        }
        else {
            for (let i = 0; i < numLocals; i += 1) {
                locals.push(0);
            }
        }
        let argFlags = 0;
        if (arg1 !== null && numLocals >= 1) {
            locals[0] = arg1;
            argFlags += BIT_0;
        }
        if (arg2 !== null && numLocals >= 2) {
            locals[1] = arg2;
            argFlags += BIT_1;
        }
        if (arg3 !== null && numLocals >= 3) {
            locals[2] = arg3;
            argFlags += BIT_2;
        }
        if (arg4 !== null && numLocals >= 4) {
            locals[3] = arg4;
            argFlags += BIT_3;
        }
        if (arg5 !== null && numLocals >= 5) {
            locals[4] = arg5;
            argFlags += BIT_4;
        }
        if (arg6 !== null && numLocals >= 6) {
            locals[5] = arg6;
            argFlags += BIT_5;
        }
        if (arg7 !== null && numLocals >= 7) {
            locals[6] = arg7;
            argFlags += BIT_6;
        }
        Stack.pushFrame({
            returnPC,
            store,
            storeVar,
            locals,
            stack: [],
            argFlags,
            interruptCallback,
        });
    }
    static jump(offset) {
        PC.offsetPC(offset);
    }
    static async return(value) {
        if (value < 0 || value >= BIT_16) {
            throw new Error(`value out of range ${value}`);
        }
        const frame = Stack.popFrame();
        if (frame.store) {
            Variable.writeVar(frame.storeVar, value);
        }
        PC.setPC(frame.returnPC);
        if (frame.interruptCallback !== null) {
            await frame.interruptCallback(value);
        }
    }
    static store(value) {
        const varNum = PC.readByte();
        Variable.writeVar(varNum, value);
    }
    static CheckArgumentNumber(argumentNumber) {
        if (argumentNumber < 1 || argumentNumber > 7) {
            throw new Error(`argumentNumber out of range ${argumentNumber}`);
        }
        const frame = Stack.currentFrame();
        // eslint-disable-next-line no-bitwise
        if ((frame.argFlags & BITS[argumentNumber - 1]) !== 0) {
            return true;
        }
        return false;
    }
    static catch() {
        const frameCount = Stack.frameCount();
        // catch must perform its own store
        this.store(frameCount);
    }
    static async throw(value, frameCount) {
        if (frameCount < 1 || frameCount > Stack.frameCount()) {
            throw new Error(`bad frameCount ${frameCount}`);
        }
        while (Stack.frameCount() > frameCount) {
            Stack.popFrame();
        }
        await this.return(value);
    }
}
