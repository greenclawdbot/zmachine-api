import Header from './header';
import Icon from './icon';
import ScreenState, { MONOSPACE_FONT, GRAPHICS_FONT, } from '../state/screen';
import ZSCII from './zscii';
import { makeColorCode } from '../utils/methods';
export default class Screen {
    static printString(str) {
        const { screen, window, cursor, monospace, foreground, background, bold, italic, columns, rows, } = this.activeWindowSettings();
        this.unsetCursor(screen, window, cursor);
        const { lines } = window;
        for (let i = 0; i < str.length; i += 1) {
            const char = str.charAt(i);
            if (char === '\n') {
                cursor.y += 1;
                if (rows && cursor.y >= rows) {
                    cursor.y = rows - 1;
                }
                cursor.x = 0;
            }
            else {
                while (cursor.y >= lines.length) {
                    lines.push({
                        key: ScreenState.getNextKey(),
                        serial: 0,
                        chars: [],
                    });
                }
                const line = lines[cursor.y];
                const { chars } = line;
                while (cursor.x >= chars.length) {
                    chars.push({
                        kind: 'BLANK',
                        key: ScreenState.getNextKey(),
                        background: ScreenState.backgroundDefault,
                        monospace,
                        cursor: false,
                    });
                }
                if (ScreenState.font === GRAPHICS_FONT) {
                    chars[cursor.x] = {
                        kind: 'ICON',
                        key: ScreenState.getNextKey(),
                        background,
                        uri: Icon.getIconURI(char.charCodeAt(0), foreground),
                        cursor: false,
                    };
                }
                else {
                    chars[cursor.x] = {
                        kind: 'LETTER',
                        key: ScreenState.getNextKey(),
                        foreground,
                        background,
                        monospace,
                        bold,
                        italic,
                        letter: char,
                        cursor: false,
                    };
                }
                cursor.x += 1;
                if (columns && cursor.x >= columns) {
                    // wrap to next line
                    cursor.x = 0;
                    cursor.y += 1;
                    if (rows && cursor.y >= rows) {
                        // stop at bottom right
                        cursor.x = columns - 1;
                        cursor.y = rows - 1;
                    }
                }
                line.serial += 1;
            }
        }
        this.resetCursor(screen, window, cursor, monospace);
    }
    static printZSCII(zscii) {
        const str = ZSCII.outputZSCIIToString(zscii);
        this.printString(str);
    }
    static backspace() {
        const { screen, window, cursor, monospace, columns, } = this.activeWindowSettings();
        this.unsetCursor(screen, window, cursor);
        const { lines } = window;
        if (cursor.x > 0) {
            cursor.x -= 1;
            if (cursor.y < lines.length) {
                const line = lines[cursor.y];
                const { chars } = line;
                if (cursor.x < chars.length) {
                    // the cursor has backed on top of a character
                    // erase this character
                    chars[cursor.x] = {
                        kind: 'BLANK',
                        key: ScreenState.getNextKey(),
                        background: ScreenState.backgroundDefault,
                        monospace,
                        cursor: false,
                    };
                    line.serial += 1;
                }
            }
        }
        else if (cursor.y > 0) {
            cursor.y -= 1;
            if (cursor.y < lines.length) {
                const line = lines[cursor.y];
                const { chars } = line;
                cursor.x = chars.length;
                if (columns && cursor.x >= columns) {
                    // we advanced due to wrapping (as opposed to a new line)
                    // delete the last character
                    cursor.x = columns - 1;
                    chars[cursor.x] = {
                        kind: 'BLANK',
                        key: ScreenState.getNextKey(),
                        background: ScreenState.backgroundDefault,
                        monospace,
                        cursor: false,
                    };
                    line.serial += 1;
                }
            }
            else {
                cursor.x = 0;
            }
        }
        this.resetCursor(screen, window, cursor, monospace);
    }
    static printTable(zsciiTable) {
        const { screen, window, cursor, } = this.activeWindowSettings();
        const { x, y } = cursor;
        for (let i = 0; i < zsciiTable.length; i += 1) {
            this.unsetCursor(screen, window, cursor);
            cursor.x = x;
            cursor.y = y + i;
            this.printZSCII(zsciiTable[i]); // which also resets the cursor in the new position
        }
    }
    static setAppSize(width, height) {
        // Let's always use the same character height to width ratio, 2:1
        // and always an integer height and width, for better icon tiling
        // In the upper window, we make a View for each character and put the letter in it
        // In the lower window, the height is the line height, and text is tighter together
        // Font sizes are chosen to fit in the upper boxes nicely, perhaps with a
        // formula of fontSize = charHeight * 5/6
        const ratio = 2;
        let charWidth = 8;
        let charHeight = charWidth * ratio;
        let columns = Math.floor(width / charWidth);
        let rows = Math.floor(height / charHeight);
        if (columns < 52) {
            // some old games break with too few columns
            // rework such that we have at least a width of 50;
            // with a character margin left and right
            columns = 52;
            charWidth = Math.floor(width / columns);
            charHeight = charWidth * ratio;
            rows = Math.floor(height / charHeight);
        }
        if (rows < 20) {
            // don't break old games by having too few rows
            // some break at 17;
            // rework with a height of 18
            // with a character margin top and bottom
            rows = 20;
            charWidth = Math.floor(height / rows / ratio);
            charHeight = charWidth * ratio;
            columns = Math.floor(width / charWidth);
        }
        if (columns > 257) {
            columns = 257;
        }
        if (rows > 257) {
            rows = 257;
        }
        const screen = ScreenState.getScreen();
        screen.columns = columns - 2;
        screen.rows = rows - 2;
        screen.charWidth = charWidth;
        screen.charHeight = charHeight;
    }
    static clearScreen() {
        const version = Header.version();
        const screen = ScreenState.getScreen();
        const { rows } = screen;
        let rowsUsed = 0;
        if (version <= 3) {
            // we have a status line
            screen.status.display = true;
            screen.status.name = '';
            screen.status.progress = '';
            screen.status.serial += 1;
            rowsUsed += 1;
        }
        else {
            screen.status.display = false;
            screen.status.name = '';
            screen.status.progress = '';
            screen.status.serial += 1;
        }
        // upper window
        screen.upperWindow.lines = [];
        screen.upperWindow.rows = 0;
        ScreenState.upperTrueRows = 0;
        ScreenState.upperSeenRows = 0;
        ScreenState.upperCursor = { x: 0, y: 0 };
        screen.upperWindow.serial += 1;
        // lower window
        screen.lowerWindow.lines = [];
        screen.lowerWindow.rows = rows - rowsUsed;
        if (version < 5 && screen.lowerWindow.rows > 0) {
            // early versions start with the cursor in the bottom left
            ScreenState.lowerCursor = { x: 0, y: screen.lowerWindow.rows - 1 };
        }
        else {
            // later versions start at the top
            ScreenState.lowerCursor = { x: 0, y: 0 };
        }
        ScreenState.activeWindow = 'LOWER';
        const { monospace } = this.activeWindowSettings();
        this.resetCursor(screen, screen.lowerWindow, ScreenState.lowerCursor, monospace);
        this.flush();
    }
    static splitWindow(lines) {
        const version = Header.version();
        const screen = ScreenState.getScreen();
        let { rows } = screen;
        if (version <= 3) {
            // we have a status line
            rows -= 1;
        }
        const oldRows = ScreenState.upperTrueRows;
        ScreenState.upperTrueRows = lines;
        if (lines > screen.upperWindow.rows) {
            screen.upperWindow.rows = lines;
            screen.lowerWindow.rows = rows - lines;
        }
        if (lines > oldRows) {
            for (let i = oldRows; i < lines; i += 1) {
                screen.upperWindow.lines[i] = {
                    key: ScreenState.getNextKey(),
                    serial: 0,
                    chars: [],
                };
            }
        }
        if (ScreenState.upperCursor.y >= lines) {
            if (ScreenState.activeWindow === 'UPPER') {
                const { monospace } = this.activeWindowSettings();
                this.unsetCursor(screen, screen.upperWindow, ScreenState.upperCursor);
                ScreenState.upperCursor = { x: 0, y: 0 };
                this.resetCursor(screen, screen.upperWindow, ScreenState.upperCursor, monospace);
            }
            else {
                ScreenState.upperCursor = { x: 0, y: 0 };
            }
        }
        screen.upperWindow.serial += 1;
        screen.lowerWindow.serial += 1;
        screen.serial += 1;
        if (version === 3) {
            this.clearUpperWindow();
        }
        this.flush();
    }
    static clearUpperWindow() {
        const screen = ScreenState.getScreen();
        screen.upperWindow.lines = [];
        screen.upperWindow.serial += 1;
        screen.serial += 1;
        ScreenState.upperCursor = { x: 0, y: 0 };
        if (ScreenState.activeWindow === 'UPPER') {
            const { monospace } = this.activeWindowSettings();
            this.resetCursor(screen, screen.upperWindow, ScreenState.upperCursor, monospace);
        }
        const totalRows = screen.upperWindow.rows + screen.lowerWindow.rows;
        ScreenState.upperSeenRows = ScreenState.upperTrueRows;
        screen.upperWindow.rows = ScreenState.upperTrueRows;
        screen.lowerWindow.rows = totalRows - ScreenState.upperTrueRows;
        this.flush();
    }
    static clearLowerWindow() {
        const version = Header.version();
        const screen = ScreenState.getScreen();
        screen.lowerWindow.lines = [];
        if (version < 5 && screen.lowerWindow.rows > 0) {
            // early versions start with the cursor in the bottom left
            ScreenState.lowerCursor = { x: 0, y: screen.lowerWindow.rows - 1 };
        }
        else {
            // later versions start at the top
            ScreenState.lowerCursor = { x: 0, y: 0 };
        }
        if (ScreenState.activeWindow === 'LOWER') {
            const { monospace } = this.activeWindowSettings();
            this.resetCursor(screen, screen.lowerWindow, ScreenState.lowerCursor, monospace);
        }
        screen.lowerWindow.serial += 1;
        screen.serial += 1;
        this.flush();
    }
    static setWindow(window) {
        const { screen, window: oldWindow, cursor: oldCursor, } = this.activeWindowSettings();
        this.unsetCursor(screen, oldWindow, oldCursor);
        if (window === 1) {
            ScreenState.activeWindow = 'UPPER';
            ScreenState.upperCursor = { x: 0, y: 0 };
            const { monospace } = this.activeWindowSettings();
            this.resetCursor(screen, screen.upperWindow, ScreenState.upperCursor, monospace);
        }
        else if (window === 0) {
            ScreenState.activeWindow = 'LOWER';
            const { monospace } = this.activeWindowSettings();
            this.resetCursor(screen, screen.lowerWindow, ScreenState.lowerCursor, monospace);
        }
        else {
            throw new Error(`Unexpected window ${window}`);
        }
    }
    static getWindow() {
        return ScreenState.activeWindow;
    }
    static setTextStyle(style) {
        // Roman (if 0), Reverse Video (if 1), Bold (if 2), Italic (4), Fixed Pitch (8)
        if (style === 0) {
            ScreenState.fontStyle = {
                reverse: false,
                monospace: false,
                bold: false,
                italic: false,
            };
        }
        else {
            // eslint-disable-next-line no-bitwise
            if ((style & 1) !== 0) {
                ScreenState.fontStyle.reverse = true;
            }
            // eslint-disable-next-line no-bitwise
            if ((style & 2) !== 0) {
                ScreenState.fontStyle.bold = true;
            }
            // eslint-disable-next-line no-bitwise
            if ((style & 4) !== 0) {
                ScreenState.fontStyle.italic = true;
            }
            // eslint-disable-next-line no-bitwise
            if ((style & 8) !== 0) {
                ScreenState.fontStyle.monospace = true;
            }
        }
    }
    static getFont() {
        return ScreenState.font;
    }
    static setFont(font) {
        ScreenState.font = font;
    }
    static setTextColor(foreground, background) {
        if (foreground === -1) {
            // default
            ScreenState.foreground = ScreenState.foregroundDefault;
        }
        else if (foreground === -2) {
            // current
        }
        else {
            // the number is fifteen bits of colour
            ScreenState.foreground = makeColorCode(foreground);
        }
        if (background === -1) {
            // default
            ScreenState.background = ScreenState.backgroundDefault;
        }
        else if (background === -2) {
            // current
        }
        else {
            // the number is fifteen bits of colour
            ScreenState.background = makeColorCode(background);
        }
    }
    static activeWindowSettings() {
        const screen = ScreenState.getScreen();
        let window;
        let cursor;
        const { reverse, bold, italic, } = ScreenState.fontStyle;
        let { monospace } = ScreenState.fontStyle;
        let { foreground, background } = ScreenState;
        let columns = null;
        let rows = null;
        if (reverse) {
            [foreground, background] = [background, foreground];
        }
        if (Header.getFlags2(1)) {
            monospace = true;
        }
        if (ScreenState.font === MONOSPACE_FONT) {
            monospace = true;
        }
        if (ScreenState.activeWindow === 'UPPER') {
            window = screen.upperWindow;
            cursor = ScreenState.upperCursor;
            monospace = true;
            columns = screen.columns;
            rows = ScreenState.upperTrueRows;
        }
        else {
            window = screen.lowerWindow;
            cursor = ScreenState.lowerCursor;
        }
        return {
            screen,
            window,
            cursor,
            monospace,
            foreground,
            background,
            bold,
            italic,
            columns,
            rows,
        };
    }
    static unsetCursor(screen, window, cursor) {
        // clears the visible cursor from the screen
        const { x, y } = cursor;
        if (y < 0 || x < 0) {
            throw new Error('bad cursor position');
        }
        const { lines } = window;
        if (y < lines.length) {
            const { chars } = lines[y];
            if (x < chars.length) {
                if (x + 1 === chars.length && chars[x].kind === 'BLANK') {
                    // removes blanks from the end of the line
                    while (chars.length > 0 && chars[chars.length - 1].kind === 'BLANK') {
                        chars.pop();
                    }
                }
                else {
                    chars[x].cursor = false;
                }
                lines[y].serial += 1;
                // eslint-disable-next-line no-param-reassign
                window.serial += 1;
                // eslint-disable-next-line no-param-reassign
                screen.serial += 1;
            }
        }
    }
    static resetCursor(screen, window, cursor, monospace) {
        // restores the visable cursor to the screen
        const { x, y } = cursor;
        if (y < 0 || x < 0) {
            throw new Error('bad cursor position');
        }
        const { lines } = window;
        while (y >= lines.length) {
            // push blank lines
            lines.push({
                key: ScreenState.getNextKey(),
                serial: 0,
                chars: [],
            });
        }
        const { chars } = lines[y];
        while (x >= chars.length) {
            // push blank chars
            chars.push({
                kind: 'BLANK',
                key: ScreenState.getNextKey(),
                background: ScreenState.backgroundDefault,
                monospace,
                cursor: false,
            });
        }
        chars[x].cursor = true;
        lines[y].serial += 1;
        // eslint-disable-next-line no-param-reassign
        window.serial += 1;
        // eslint-disable-next-line no-param-reassign
        screen.serial += 1;
    }
    static setCursor(line, column) {
        if (ScreenState.activeWindow === 'UPPER') {
            const { screen, window, cursor, monospace, } = this.activeWindowSettings();
            this.unsetCursor(screen, window, cursor);
            if (line < 0) {
                // eslint-disable-next-line no-console
                console.log(`setCursor with negative y ${line}`);
                cursor.y = 0;
            }
            else if (line >= ScreenState.upperTrueRows) {
                // eslint-disable-next-line no-console
                console.log(`setCursor below upper window ${line}`);
                this.splitWindow(line + 1);
                cursor.y = line;
            }
            else {
                cursor.y = line;
            }
            if (column < 0) {
                // eslint-disable-next-line no-console
                console.log(`setCursor with negative x ${column}`);
                cursor.x = 0;
            }
            else if (column >= screen.columns) {
                // eslint-disable-next-line no-console
                console.log(`setCursor right of upper window ${column}`);
                cursor.x = screen.columns - 1;
            }
            else {
                cursor.x = column;
            }
            this.resetCursor(screen, window, cursor, monospace);
        }
        else if (ScreenState.activeWindow === 'LOWER') {
            // Do nothing
        }
        else {
            throw new Error(`Unexpected active window ${ScreenState.activeWindow}`);
        }
    }
    static getCursor() {
        if (ScreenState.activeWindow === 'UPPER') {
            return {
                ...ScreenState.upperCursor,
            };
        }
        if (ScreenState.activeWindow === 'LOWER') {
            // I believe this should not be called,
            // but it also doesn't seem necessary to throw an error
            const screen = ScreenState.getScreen();
            const { x, y } = ScreenState.lowerCursor;
            if (y >= screen.lowerWindow.rows) {
                return {
                    x,
                    y: screen.lowerWindow.rows - 1,
                };
            }
            return { x, y };
        }
        throw new Error(`Unexpected active window ${ScreenState.activeWindow}`);
    }
    static getInputBeforeCursor(length) {
        // used for comparing to input after a timed interrupt
        // on errors, we should just return the empty array
        const { window, cursor, } = this.activeWindowSettings();
        const { lines } = window;
        if (cursor.y >= lines.length) {
            // we don't have any printing on the cursors line
            return [];
        }
        const line = lines[cursor.y];
        if (cursor.x < length) {
            // we don't have that many characters before the cursor
            return [];
        }
        const { chars } = line;
        if (cursor.x > chars.length) {
            // we don't have characters right behind the cursor
            return [];
        }
        const codes = chars.slice(cursor.x - length, cursor.x).map((char) => {
            if (char && char.kind === 'LETTER') {
                return ZSCII.stringToInputZSCII(char.letter);
            }
            return 0;
        });
        return codes;
    }
    static eraseLine() {
        const { screen, window, cursor, monospace, } = this.activeWindowSettings();
        this.unsetCursor(screen, window, cursor);
        if (cursor.y < window.lines.length) {
            const line = window.lines[cursor.y];
            while (cursor.x < line.chars.length) {
                line.chars.pop();
            }
            line.serial += 1;
        }
        this.resetCursor(screen, window, cursor, monospace);
        ScreenState.flush();
    }
    static flush() {
        ScreenState.flush();
    }
    static flushBeforeInput() {
        const screen = ScreenState.getScreen();
        if (ScreenState.upperSeenRows === screen.upperWindow.rows) {
            if (ScreenState.upperTrueRows < screen.upperWindow.rows) {
                while (screen.upperWindow.lines.length > ScreenState.upperTrueRows) {
                    screen.upperWindow.lines.pop();
                }
                const totalRows = screen.upperWindow.rows + screen.lowerWindow.rows;
                screen.upperWindow.rows = ScreenState.upperTrueRows;
                screen.lowerWindow.rows = totalRows - ScreenState.upperTrueRows;
            }
        }
        ScreenState.upperSeenRows = screen.upperWindow.rows;
        ScreenState.flush();
    }
}
