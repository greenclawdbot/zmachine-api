/* eslint-disable no-bitwise */
import Memory from '../state/memory';
import Header from './header';
import { BIT_15 } from '../utils/constants';
const ZCHAR1_MASK = 31 << 10;
const ZCHAR2_MASK = 31 << 5;
const ZCHAR3_MASK = 31;
const A0String = 'abcdefghijklmnopqrstuvwxyz';
const A1String = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
const A2String = ' \r0123456789.,!?_#\'"/\\-:()';
const A2StringV1 = ' 0123456789.,!?_#\'"/\\<-:()';
const A0Codes = A0String.split('').map((x) => x.charCodeAt(0));
const A1Codes = A1String.split('').map((x) => x.charCodeAt(0));
const A2Codes = A2String.split('').map((x) => x.charCodeAt(0));
const A2CodesV1 = A2StringV1.split('').map((x) => x.charCodeAt(0));
const UP_SHIFT = [1, 2, 0];
const DOWN_SHIFT = [2, 0, 1];
export default class Strings {
    static wordsFromZSCII(zscii, numWords) {
        const casedValues = this.casedValuesFromZSCII(zscii);
        const zChars = this.zCharsFromCasedValues(casedValues, numWords * 3);
        return this.wordsFromZChars(zChars);
    }
    static zCharsFromCasedValues(casedValues, numZChars) {
        const version = Header.version();
        let curCase = 0;
        let i = 0;
        const zChars = [];
        while (zChars.length < numZChars && i < casedValues.length) {
            // encode next code
            const [codeCase, codeValues] = casedValues[i];
            i += 1;
            if (codeCase !== curCase) {
                let shiftChar;
                if (version < 3) {
                    // choose between shift and shift lock
                    if (i < casedValues.length && casedValues[i][0] === codeCase) {
                        // shift lock
                        if (UP_SHIFT[curCase] === codeCase) {
                            shiftChar = 4;
                            curCase = UP_SHIFT[curCase];
                        }
                        else {
                            shiftChar = 5;
                            curCase = DOWN_SHIFT[curCase];
                        }
                    }
                    else if (UP_SHIFT[curCase] === codeCase) {
                        // shift up
                        shiftChar = 2;
                    }
                    else {
                        // shift down
                        shiftChar = 3;
                    }
                }
                else if (UP_SHIFT[curCase] === codeCase) {
                    // shift up
                    shiftChar = 4;
                }
                else {
                    // shift down
                    shiftChar = 5;
                }
                zChars.push(shiftChar);
            }
            let j = 0;
            while (zChars.length < numZChars && j < codeValues.length) {
                zChars.push(codeValues[j]);
                j += 1;
            }
        }
        while (zChars.length < numZChars) {
            // pad with 5
            zChars.push(5);
        }
        return zChars;
    }
    static casedValuesFromZSCII(zscii) {
        const version = Header.version();
        let A0 = A0Codes;
        let A1 = A1Codes;
        let A2 = A2Codes;
        if (version === 1) {
            A2 = A2CodesV1;
        }
        if (version >= 5) {
            const alphabetTable = Header.alphabetTable();
            if (alphabetTable > 0) {
                A0 = Memory.getBytes(alphabetTable, 26);
                A1 = Memory.getBytes(alphabetTable + 26, 26);
                A2 = Memory.getBytes(alphabetTable + 52, 26);
            }
        }
        const casedValues = [];
        for (let i = 0; i < zscii.length; i += 1) {
            const code = zscii[i];
            const index0 = A0.indexOf(code);
            if (index0 >= 0) {
                casedValues.push([0, [index0 + 6]]);
            }
            else {
                const index1 = A1.indexOf(code);
                if (index1 >= 0) {
                    casedValues.push([1, [index1 + 6]]);
                }
                else {
                    const index2 = A2.indexOf(code, 1);
                    if (index2 >= 0) {
                        casedValues.push([2, [index2 + 6]]);
                    }
                    else {
                        // encode it as a mult-character construction
                        casedValues.push([2, [6, (code & ZCHAR2_MASK) >> 5, (code & ZCHAR3_MASK)]]);
                    }
                }
            }
        }
        return casedValues;
    }
    static wordsFromZChars(zChars) {
        if (zChars.length === 0 || zChars.length % 3 !== 0) {
            throw new Error('bad zChars length');
        }
        const words = [];
        for (let i = 0; i < zChars.length; i += 3) {
            words.push((zChars[i] << 10) + (zChars[i + 1] << 5) + (zChars[i + 2]));
        }
        // set last word bit
        words[words.length - 1] += BIT_15;
        return words;
    }
    static zsciiFromWords(words, isAbbreviation = false) {
        const zChars = this.zCharsFromWords(words);
        return this.zsciiFromZChars(zChars, isAbbreviation);
    }
    static zCharsFromWords(words) {
        const zChars = [];
        for (let i = 0; i < words.length; i += 1) {
            const word = words[i];
            zChars.push((word & ZCHAR1_MASK) >> 10);
            zChars.push((word & ZCHAR2_MASK) >> 5);
            zChars.push((word & ZCHAR3_MASK));
            if ((word & BIT_15) !== 0 && i + 1 < words.length) {
                throw new Error('Unexpectedly early string end bit');
            }
            if (i + 1 === words.length && (word & BIT_15) === 0) {
                throw new Error('Missing string end bit');
            }
        }
        return zChars;
    }
    static zsciiFromZChars(zChars, isAbbreviation = false) {
        const version = Header.version();
        const zscii = [];
        let A0 = A0Codes;
        let A1 = A1Codes;
        let A2 = A2Codes;
        if (version === 1) {
            A2 = A2CodesV1;
        }
        if (version >= 5) {
            const alphabetTable = Header.alphabetTable();
            if (alphabetTable > 0) {
                A0 = Memory.getBytes(alphabetTable, 26);
                A1 = Memory.getBytes(alphabetTable + 26, 26);
                A2 = Memory.getBytes(alphabetTable + 52, 26);
            }
        }
        // state
        let baseCase = 0;
        let curCase = 0;
        let i = 0;
        while (i < zChars.length) {
            const zChar = zChars[i];
            i += 1;
            let nextCase = baseCase;
            if (zChar === 0) {
                zscii.push(32); // space
            }
            else if (zChar === 1) {
                if (version === 1) {
                    zscii.push(13); // newline
                }
                else if (isAbbreviation) {
                    throw new Error('recursive abbrevation');
                }
                else if (i < zChars.length) {
                    const abbreviation = zChars[i];
                    i += 1;
                    zscii.push(...this.zsciiFromAbbreviation(abbreviation));
                }
                else {
                    throw new Error('partial abbreviation');
                }
            }
            else if (zChar === 2) {
                if (version < 3) {
                    nextCase = UP_SHIFT[baseCase];
                }
                else if (isAbbreviation) {
                    throw new Error('recursive abbrevation');
                }
                else if (i < zChars.length) {
                    const abbreviation = zChars[i] + 32;
                    i += 1;
                    zscii.push(...this.zsciiFromAbbreviation(abbreviation));
                }
                else {
                    throw new Error('partial abbreviation');
                }
            }
            else if (zChar === 3) {
                if (version < 3) {
                    nextCase = DOWN_SHIFT[baseCase];
                }
                else if (isAbbreviation) {
                    throw new Error('recursive abbrevation');
                }
                else if (i < zChars.length) {
                    const abbreviation = zChars[i] + 64;
                    i += 1;
                    zscii.push(...this.zsciiFromAbbreviation(abbreviation));
                }
                else {
                    throw new Error('partial abbreviation');
                }
            }
            else if (zChar === 4) {
                if (version < 3) {
                    nextCase = UP_SHIFT[baseCase];
                    baseCase = nextCase;
                }
                else {
                    nextCase = UP_SHIFT[baseCase];
                }
            }
            else if (zChar === 5) {
                if (version < 3) {
                    nextCase = DOWN_SHIFT[baseCase];
                    baseCase = nextCase;
                }
                else {
                    nextCase = DOWN_SHIFT[baseCase];
                }
            }
            else if (zChar === 6 && curCase === 2) {
                // next two zChars are a 10 bit char code
                if (i + 1 < zChars.length) {
                    zscii.push((zChars[i] * 32) + zChars[i + 1]);
                }
                else if (isAbbreviation) {
                    throw new Error('abbrevation ends with partial multi-character construction');
                }
                i += 2;
            }
            else if (curCase === 0) {
                zscii.push(A0[zChar - 6]);
            }
            else if (curCase === 1) {
                zscii.push(A1[zChar - 6]);
            }
            else if (curCase === 2) {
                zscii.push(A2[zChar - 6]);
            }
            curCase = nextCase;
        }
        return zscii;
    }
    static zsciiFromAbbreviation(abbreviation) {
        const abbreviationTable = Header.abbreviationTable();
        const entryAddr = abbreviationTable + (2 * abbreviation);
        let abbreviationAddr = Memory.getWord(entryAddr) * 2;
        const words = [];
        let word = 0;
        while ((word & BIT_15) === 0) {
            word = Memory.getWord(abbreviationAddr);
            abbreviationAddr += 2;
            words.push(word);
        }
        const isAbbreviation = true;
        return this.zsciiFromWords(words, isAbbreviation);
    }
}
