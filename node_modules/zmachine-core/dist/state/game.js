import { calculateChecksum } from '../utils/methods';
const MAX_UNDOS = 3;
// singleton for storing the story file and save restore callbacks
class GameState {
    constructor() {
        this.file = [];
        this.undos = [];
        this.saver = async () => {
            throw new Error('no saver attached');
        };
        this.loader = async () => {
            throw new Error('no loader attached');
        };
        this.statusSetter = () => {
            throw new Error('no status setter attached');
        };
        this.noiseMaker = (noiseType) => {
            // eslint-disable-next-line no-console
            console.log(`Noise: ${noiseType}`);
        };
        this.transcriptWriter = (line) => {
            // eslint-disable-next-line no-console
            console.log(line);
        };
        this.defaultCommandBuffer = [];
        this.commandRecorder = (line) => {
            this.defaultCommandBuffer.push(line);
        };
        this.commandReplayer = async () => {
            const command = this.defaultCommandBuffer.shift();
            if (command === undefined) {
                return null;
            }
            return command;
        };
    }
    setStoryFile(file) {
        this.file = file.slice();
    }
    fileLength() {
        const version = this.file[0];
        const lengthWord = (this.file[26] * 256) + this.file[27];
        if (version < 4) {
            return 2 * lengthWord;
        }
        if (version < 6) {
            return 4 * lengthWord;
        }
        return 8 * lengthWord;
    }
    checksum() {
        return calculateChecksum(this.file);
    }
    release() {
        return (this.file[2] * 256) + this.file[3];
    }
    serial() {
        return this.file.slice(18, 24).map((x) => {
            if ((x >= 48 && x < 58)
                || (x >= 65 && x < 91)
                || (x >= 97 && x < 123)) {
                // alphanumeric
                return String.fromCharCode(x);
            }
            return '-';
        }).join('');
    }
    searchForUUID() {
        // search for the pattern UUID://<uuid>//
        // search for the pattern [85, 85, 73, 68, 58, 47, 47], a uuid,  [47, 47]
        let i = this.file.indexOf(85, 0);
        while (i >= 0) {
            // check for the pattern
            if (i + 44 < this.file.length
                && this.file[i + 1] === 85
                && this.file[i + 2] === 73
                && this.file[i + 3] === 68
                && this.file[i + 4] === 58
                && this.file[i + 5] === 47
                && this.file[i + 6] === 47
                && this.file[i + 43] === 47
                && this.file[i + 44] === 47) {
                const bytes = this.file.slice(i + 7, i + 43);
                const good = bytes.every((byte) => {
                    if (byte >= 48 && byte < 58) {
                        // 0 - 9
                        return true;
                    }
                    if (byte >= 65 && byte < 71) {
                        // A - F
                        return true;
                    }
                    if (byte >= 97 && byte < 103) {
                        // a - f
                        return true;
                    }
                    if (byte === 45) {
                        // hyphen
                        return true;
                    }
                    return false;
                });
                if (good) {
                    return String.fromCharCode(...bytes);
                }
            }
            i = this.file.indexOf(85, i + 1);
        }
        return null;
    }
    IFID() {
        const release = this.release();
        const serial = this.serial();
        const checksum = this.checksum().toString(16).padStart(4, '0');
        const uuid = this.searchForUUID();
        if (uuid) {
            return uuid;
        }
        if (serial !== '000000' && '012345679'.includes(serial[0])) {
            return `ZCODE-${release}-${serial}-${checksum}`;
        }
        return `ZCODE-${release}-${serial}`;
    }
    getStoryFile() {
        return this.file.slice();
    }
    attachStatusSetter(setter) {
        this.statusSetter = setter;
    }
    attachSaver(saver) {
        this.saver = saver;
    }
    attachLoader(loader) {
        this.loader = loader;
    }
    attachNoiseMaker(noiseMaker) {
        this.noiseMaker = noiseMaker;
    }
    attachTranscriptWriter(transcriptWriter) {
        this.transcriptWriter = transcriptWriter;
    }
    attachCommandRecorder(commandRecorder) {
        this.commandRecorder = commandRecorder;
    }
    attachCommandReplayer(commandReplayer) {
        this.commandReplayer = commandReplayer;
    }
    async saveGame(bytes) {
        const IFID = this.IFID();
        await this.saver(bytes, 'SAVED_GAME', IFID, 'GAME.SAV', false, false);
    }
    async loadGame() {
        const IFID = this.IFID();
        return this.loader('SAVED_GAME', IFID, 'GAME.SAV', false, false);
    }
    async saveTable(bytes, fileName, doPrompt, doNotPrompt) {
        const IFID = this.IFID();
        await this.saver(bytes, 'TABLE', IFID, fileName, doPrompt, doNotPrompt);
    }
    async loadTable(fileName, doPrompt, doNotPrompt) {
        const IFID = this.IFID();
        return this.loader('TABLE', IFID, fileName, doPrompt, doNotPrompt);
    }
    makeNoise(noiseType) {
        this.noiseMaker(noiseType);
    }
    writeTranscriptLine(line) {
        this.transcriptWriter(line);
    }
    recordCommand(command) {
        this.commandRecorder(command);
    }
    async replayCommand() {
        return this.commandReplayer();
    }
    setStatus(status) {
        this.statusSetter(status);
    }
    pushUndo(state) {
        while (this.undos.length >= MAX_UNDOS) {
            this.undos.shift();
        }
        this.undos.push(state);
    }
    popUndo() {
        const undo = this.undos.pop();
        if (!undo) {
            return null;
        }
        return undo;
    }
}
const singleton = new GameState();
export default singleton;
