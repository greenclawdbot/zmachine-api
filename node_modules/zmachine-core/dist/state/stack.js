import { BIT_16 } from '../utils/constants';
// singleton for call stack
class Stack {
    constructor() {
        this.frames = [];
    }
    init() {
        this.frames = [{
                returnPC: 0,
                store: false,
                storeVar: 0,
                locals: [],
                stack: [],
                argFlags: 0,
                interruptCallback: null,
            }];
    }
    pushFrame(frame) {
        this.frames.push(frame);
    }
    popFrame() {
        const frame = this.frames.pop();
        if (frame === undefined) {
            throw new Error('popped off of empty frames!');
        }
        if (this.frames.length === 0) {
            throw new Error('popped off last frame!');
        }
        return frame;
    }
    frameCount() {
        return this.frames.length;
    }
    currentFrame() {
        return this.frames[this.frames.length - 1];
    }
    pushStack(word) {
        if (word < 0 || word >= BIT_16) {
            throw new Error(`word out of range ${word}`);
        }
        const frame = this.currentFrame();
        frame.stack.push(word);
    }
    popStack() {
        const frame = this.currentFrame();
        const word = frame.stack.pop();
        if (word === undefined) {
            throw new Error('popped off of empty stack!');
        }
        return word;
    }
    getLocal(localNum) {
        const frame = this.currentFrame();
        if (localNum < 0 || localNum >= frame.locals.length) {
            throw new Error(`localNum out of range ${localNum}`);
        }
        return frame.locals[localNum];
    }
    setLocal(localNum, word) {
        if (word < 0 || word >= BIT_16) {
            throw new Error(`word out of range ${word}`);
        }
        const frame = this.currentFrame();
        if (localNum < 0 || localNum >= frame.locals.length) {
            throw new Error(`localNum out of range ${localNum}`);
        }
        frame.locals[localNum] = word;
    }
    saveFrames() {
        const framesClone = [];
        for (let i = 0; i < this.frames.length; i += 1) {
            const frame = this.frames[i];
            if (frame.interruptCallback !== null) {
                throw new Error('getFrames called during interrupt routine');
            }
            const frameClone = {
                returnPC: frame.returnPC,
                store: frame.store,
                storeVar: frame.storeVar,
                locals: frame.locals.slice(),
                stack: frame.stack.slice(),
                argFlags: frame.argFlags,
                interruptCallback: frame.interruptCallback,
            };
            framesClone.push(frameClone);
        }
        return framesClone;
    }
    restoreFrames(frames) {
        this.frames = [];
        for (let i = 0; i < frames.length; i += 1) {
            const frame = frames[i];
            const frameClone = {
                returnPC: frame.returnPC,
                store: frame.store,
                storeVar: frame.storeVar,
                locals: frame.locals.slice(),
                stack: frame.stack.slice(),
                argFlags: frame.argFlags,
                interruptCallback: frame.interruptCallback,
            };
            this.frames.push(frameClone);
        }
    }
}
const singleton = new Stack();
export default singleton;
